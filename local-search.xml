<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>webpack工程化</title>
    <link href="/2024/04/15/webpack%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <url>/2024/04/15/webpack%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h4 id="webpack工程化-面试题"><a href="#webpack工程化-面试题" class="headerlink" title="webpack工程化-面试题"></a>webpack工程化-面试题</h4><h2 id="webpack有哪些常见的loader-你用过哪些loader"><a href="#webpack有哪些常见的loader-你用过哪些loader" class="headerlink" title="webpack有哪些常见的loader? 你用过哪些loader?"></a>webpack有哪些常见的loader? 你用过哪些loader?</h2><ul><li>raw-loader: 加载文件原始内容</li><li>file-loader: 把文件输出到文件夹中，在代码中通过相对url<br>去引用输出的文件夹（包含图片、字体）</li><li>url-loader：和file-loader类似，区别是用户可以设置一个阈值。 大于阈值会交给file-loader 处理，小于阈值则返回base64编码（一般用来处理图片）</li><li>source-map-loader：加载额外的source-map文件，方便断点调试</li><li>image-loader：加载并压缩图片文件</li><li>json-loader：加载json文件</li><li>babel-loader：将es6 装换成es5</li><li>ts-loader：将ts 语音转换成 js</li><li>sass-loader、less-loader：都是转换成css</li><li>css-loader：加载css</li><li>style-loader： 把css注入到js中，通过dom操作加载css</li><li>postcss-loader：扩展css语法，使用下一代css</li><li>eslint-loader、tslint-loader:代码检查。</li><li>vue-loader：加载vue.js单文件组件。</li></ul><h2 id="webpack-有哪些常见的Plugin-你用过哪些Plugin"><a href="#webpack-有哪些常见的Plugin-你用过哪些Plugin" class="headerlink" title="webpack 有哪些常见的Plugin? 你用过哪些Plugin?"></a>webpack 有哪些常见的Plugin? 你用过哪些Plugin?</h2><ul><li>define-plugin：定义环境变量，</li><li>ignore-plugin：忽略部分文件</li><li>html-webpack-plugin：简化html文件创建</li><li>uglifyjs-webpack-plugin：压缩js</li><li>mini-css-extract-plugin：分离样式文件，css提取为单独的文件，支持按需加载</li><li>clean-webpack-plugin：目录清理（用在下次打包之前把上次打包的内容清理掉）</li><li>webpack-bundle-analyzer：可视化webpack输出文件的体积。用于分析当前项目依赖文件的体积大小。</li><li>speed-measure-webpack-plugin：分析每个loader 和 plugin 执行耗时</li></ul><h2 id="说说Loader-和Plugin-的区别"><a href="#说说Loader-和Plugin-的区别" class="headerlink" title="说说Loader 和Plugin 的区别"></a>说说Loader 和Plugin 的区别</h2><h6 id="作用上"><a href="#作用上" class="headerlink" title="作用上"></a>作用上</h6><ul><li>loader 本质是一个函数，对接收到的内容进行转换，返回转换后的结果，webpack只认识js，所以loader就相当于翻译官。对其他类型资源进行转译和预处理。</li><li>plugin：是插件，它基于事件流框架 Tabable，可以扩展webpack功能，在webpack运行的生命周期中会<strong>广播很多事件</strong>。plugin可以监听这些事件，在<strong>适合的时机</strong>通过webpackapi 改变输出的结果。</li></ul><h6 id="结构上"><a href="#结构上" class="headerlink" title="结构上"></a>结构上</h6><ul><li>loader ：在module.rules 中进行配置，类型是数组，每项都是对象，对象包含（test 文件类型，loader 对应的模块加载器，option 对应的参数）</li><li>plugin：每个plugin都需要单独配置，类型是数组，每项plugin是一个plugin实例，参数通过构造函数传入。</li></ul><h2 id="webpack-构建流程简单说一下"><a href="#webpack-构建流程简单说一下" class="headerlink" title="webpack 构建流程简单说一下"></a>webpack 构建流程简单说一下</h2><p>它的运行流程是一个串行的过程。<br>1、初始化参数：从<a href="">配置文件</a>和shell语句中读取并且合并参数，得到最终的参数。<br>2、开始编译：初始化Compiler 对象，加载所有的配置插件。执行对象run方法，开始编译。<br>3、确定入口：根据配置的entry找到所有入口<br>4、翻译模块：调用所有的loader 对模块进行编译，找出模块依赖的模块，再<strong>递归</strong>本步骤直到所有入口依赖的文件都经过处理。<br>5、完成模块编译：经过loader翻译完所有模块后的最终内容以及它们之间的依赖关系。<br>6、输出资源：根据入口以及它们依赖关系组装成一个个包含多个模块的<strong>chunk</strong>，再把每个<strong>chunk 转换成单独的文件</strong>加入到输出列表中。（这里可以修改输出内容，并且是修改的最后一个机会）<br>7、输出完成：根据配置确定输出的路径和文件名，把文件内容写到文件中，</p><blockquote><p>在上面流程中，webpack 会在特定的时间点广播特定事件，插件在监听到事件后调用webpack 提供的API 改变输出结果</p></blockquote><h2 id="使用webpack开发时，使用过哪些可以提高效率的插件？"><a href="#使用webpack开发时，使用过哪些可以提高效率的插件？" class="headerlink" title="使用webpack开发时，使用过哪些可以提高效率的插件？"></a>使用webpack开发时，使用过哪些可以提高效率的插件？</h2><ul><li>webpack-dashboard：更友好的展示的展示相关包信息。</li><li>webpack-merge：提取公共配置，可以将多个配置文件合并，减少代码重复。</li><li>speed-measure-webpack-plugin：分析 loader 和 plugin 的耗时，从而分析构建过程中的性能瓶颈。</li><li>size-plugin：监控资源体积变化，尽早发现问题。</li><li>HotModuleReplacementPlugin：模块热替换。</li></ul><h2 id="如何优化webpack-的构建速度？"><a href="#如何优化webpack-的构建速度？" class="headerlink" title="如何优化webpack 的构建速度？"></a>如何优化webpack 的构建速度？</h2><ol><li>使用高版本webpack 和 node.js</li><li>多进程 &#x2F; 多实例构建 thread-loader</li><li>压缩代码 、多进程并行压缩‘</li></ol><blockquote><p>1）webpack-paralle-uglify-plugin ：可以并行运行 UglifyJS 插件，从而更加充分、合理的使用 CPU<br>资源，从而大大减少构建时间 2）terser-webpack-plugin ：它使用 Terser 库来执行压缩，Terser<br>是一个用于压缩 JavaScript 代码的工具，可以对代码进行简单的混淆，以及删除未使用的代码和注释等优化。 3）<br>mini-css-extract-plugin ： 可以避免将 CSS 代码打包到 JavaScript 文件中，减少 JavaScript<br>的体积，同时也可以使得 CSS 文件可以被浏览器缓存，提高页面加载速度。</p></blockquote><ol start="4"><li>图片压缩 （imagemin、image-webpack-plugin）</li><li>缩小打包作用域<br>1)、通过exclude &#x2F; include 来确定loader 规则范围。<br>2)、设置resolve.extensions.<br>3)、resolve.modules</li><li>提取页面公共的资源<br>1)、基础包分离<br>2)、使用html-webpack-externals-plugin 基础包通过cdn引入，不打入bundle 中。<br>3)、使用splitchunksplugin 将代码拆分成多个块，以便在不同的环境中按需加载。</li><li>充分利用缓存提升二次构建速度。<br>1)、使用 babel-loader 开启缓存<br>2)、terser-webpack-plugin 开启缓存<br>3)、cache-loader 或者 hard-source-webpack-plugin</li><li>tree shaking (没有用过的模块代码进行标记，从最终bundle 中去掉)</li></ol><h2 id="文件指纹是什么？怎么用？"><a href="#文件指纹是什么？怎么用？" class="headerlink" title="文件指纹是什么？怎么用？"></a>文件指纹是什么？怎么用？</h2><p>文件指纹：打包后输出的文件名后缀。</p><ul><li>hash：和整个项目构建相关的，只有项目文件改变、项目的hash值就会改变。</li><li>chunkHash：和webpack打包的chunk 相关，不同的entry产生不同的chunkHash，</li><li>contentHash：根据文件内容定义hash，文件内容不变contentHash就不会变。</li></ul><h5 id="js的文件指纹设置。"><a href="#js的文件指纹设置。" class="headerlink" title="js的文件指纹设置。"></a>js的文件指纹设置。</h5><p>主要设置output 的 fllename 使用 chunkhash.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">entry</span>: &#123;<span class="hljs-attr">spp</span>: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>, <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;./src/search.js&#x27;</span>&#125;,<br><span class="hljs-attr">output</span>: &#123;<span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name][chunkhash:8].js&#x27;</span>,<span class="hljs-attr">path</span>:_dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>&#125;<br><span class="hljs-comment">// chunkhash:8 是设置对应的长度</span><br>&#125;<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><h5 id="css-文件指纹设置"><a href="#css-文件指纹设置" class="headerlink" title="css 文件指纹设置"></a>css 文件指纹设置</h5><p>设置MiniCssExtractPlugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">entry</span>: &#123;<span class="hljs-attr">spp</span>: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>, <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;./src/search.js&#x27;</span>&#125;,<br><span class="hljs-attr">output</span>: &#123;<span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name][chunkhash:8].js&#x27;</span>,<span class="hljs-attr">path</span>:_dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>&#125;,<br><span class="hljs-attr">plugin</span>: [<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">MinCssExtractPlugin</span>(&#123; <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;[name][contenthash:8].css&#x27;</span>&#125;),<br>]<br>&#125;<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><h5 id="图片相关文件指纹设置"><a href="#图片相关文件指纹设置" class="headerlink" title="图片相关文件指纹设置"></a>图片相关文件指纹设置</h5><p>设置 file-loader 中的name</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    <span class="hljs-attr">output</span>: &#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>      <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>    &#125;, <br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpg|gif)$/</span>,<br>                <span class="hljs-attr">use</span>: [<br>&#123;<br>  <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>  <span class="hljs-attr">option</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;img/[name][hash:8].[ext]&#x27;</span>&#125;,<br>&#125;<br>],<br>&#125;<br>]<br>&#125;<br>&#125;<br><span class="hljs-number">123456789101112131415161718192021</span><br></code></pre></td></tr></table></figure><h2 id="是否写过loader？简单描写一下编写loader-的思路？"><a href="#是否写过loader？简单描写一下编写loader-的思路？" class="headerlink" title="是否写过loader？简单描写一下编写loader 的思路？"></a>是否写过loader？简单描写一下编写loader 的思路？</h2><ul><li>loader是支持链式调用的，所有在开发中需要严格遵守单一职责。每个loader负责自己所需要负责的事情。</li><li>loader是运行在nodejs中的，可以调用nodejs api 或者安装第三方模块调用。 传给loader 的原内容是 utf-8</li><li>编码的字符串 尽可能异步化loader ，如果计算量小的化同步也可以</li><li>loader 是无状态的，不应该在loader 中保留状态</li><li>开发loader 时可以使用 loader-utils schema-utils 工具 还可以（通过npm link 和<br>resolveloader 这两种方式）加载本地的loader 方法</li></ul><h2 id="是否写过Plugin？简单描写一下编写Plugin的思路？"><a href="#是否写过Plugin？简单描写一下编写Plugin的思路？" class="headerlink" title="是否写过Plugin？简单描写一下编写Plugin的思路？"></a>是否写过Plugin？简单描写一下编写Plugin的思路？</h2><ul><li>webpack运行生命周期中会广播出很多事件，让plugin 监听事件，特定阶段钩入想要添加的自定义插件内容</li><li>webpack通过tapable 事件流机制保证插件有序性，使系统的扩张性很好</li></ul><p>compiler 暴露整个生命周期相关钩子<br>compliation 暴雷与模块和依赖有关的颗粒度更小的事件钩子<br>plugin 需要再原型上绑定apply方法，才能访问compiler 实例。<br>插件接收 compiler 、compliation 都是同一个引用。<br>找到合适的事件点完成想要执行的内容，</p><h2 id="说说Babel-原理"><a href="#说说Babel-原理" class="headerlink" title="说说Babel 原理"></a>说说Babel 原理</h2><p>在 webpack 中，Babel 主要用于将 ECMAScript 2015+版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其它环境中。Babel 的转化过程如下：</p><ol><li>Parse：使用 babylon 将原始代码转换为抽象语法树。</li><li>Transform：通过 babel-traverse 对前面的抽象语法树进行遍历修改，并获得新的抽象语法树。</li><li>Generator：使用 babel-generator 将抽象语法树转换为代码。</li></ol><p>这三个操作通过 babel-core 合成一个对外的 API 供外界使用。</p><h2 id="source-map-是什么？生产环境怎么用？"><a href="#source-map-是什么？生产环境怎么用？" class="headerlink" title="source map 是什么？生产环境怎么用？"></a>source map 是什么？生产环境怎么用？</h2><p>Source Map 用于将编译、打包、压缩后的代码映射回源代码。</p><p>在生产环境中使用 Source Map 有以下几个步骤：</p><ol><li>在构建过程中生成 Source Map：确保你的构建工具（如 webpack）配置为生成 Source Map。</li><li>部署包含 Source Map 的构建产物：将生成的 Source Map 与构建后的代码一起部署到生产环境。</li><li>在开发工具中启用 Source Map：这样可以在浏览器中查看原始源代码，并在调试时将错误和堆栈跟踪映射回原始代码。</li></ol><p>使用 Source Map 的好处包括：</p><ol><li>更好的调试体验：可以在生产环境中查看和调试原始代码。</li><li>提高开发效率：更容易找到和解决问题。</li></ol><p>然而，需要注意的是，使用 Source Map 会增加构建产物的大小，可能会对性能产生一定影响。因此，在生产环境中应谨慎使用，并在必要时进行优化。</p><h2 id="文件监听原理"><a href="#文件监听原理" class="headerlink" title="文件监听原理"></a>文件监听原理</h2><p>Webpack 文件监听的原理是通过<strong>轮询</strong>判断文件的最后编辑时间是否发生变化。Webpack 首先存储文件的修改时间，下次再有修改时会与上次修改时间进行比对。如果发现不一致，Webpack 不会立即告诉监听者，而是将文件修改缓存起来，等待一段时间。在等待期间，如果有其他文件发生变化，Webpack 会将变化列表一起构建，并生成到 bundle 文件夹。</p><p>文件监听的目的是在发现文件发生变化时，自动重新构建出新的输出文件。开启监听模式有两种方式，在启动 Webpack 命令时带上 –watch 参数，或在配置 webpack.config.js 中设置 watch: true。构建完成后，输出的文件会被放入磁盘中。</p><h2 id="webpack-热更新原理"><a href="#webpack-热更新原理" class="headerlink" title="webpack 热更新原理"></a>webpack 热更新原理</h2><p>Webpack 的热更新（Hot Module Replacement，简称 HMR）是一种在开发时提供实时更新的功能，它使得在修改代码后，不需要完全刷新页面就能立即看到更新的效果。HMR 的原理涉及以下几个主要步骤：</p><ol><li><p>启动时建立 WebSocket 连接：在项目启动时，Webpack 会创建与开发服务器的 WebSocket 连接，用于在构建完成后接收更新的模块。</p></li><li><p>构建编译阶段：Webpack 在编译时会在每个模块中注入 HMR 运行时代码。该代码会监听源代码的变化，并通知 HMR runtime 进行处理。</p></li><li><p>文件监控：Webpack 会监控所有入口文件及其依赖的文件，一旦检测到文件发生变化，会触发重新编译。</p></li><li><p>构建完成：当编译完成后，Webpack 会将编译结果发送给开发服务器，并通过 WebSocket 通知客户端有新的资源可用。</p></li></ol><h2 id="webpack-事件机制了解吗？"><a href="#webpack-事件机制了解吗？" class="headerlink" title="webpack 事件机制了解吗？"></a>webpack 事件机制了解吗？</h2><blockquote><p>常见事件</p><ul><li>before-run：开始执行构建之前触发，可以用于清理上一次构建的临时文件或状态</li><li>run：开始执行构建触发</li><li>before-compile：开始编译代码前触发，可以用于添加一些额外的编辑配置或者预处理代码</li><li>compile：开始编译，可用于监听编译过程或编译处理错误</li><li>this-compilation：创建新的 Compilation 对象触发，Compilation 对象代表当前编辑过程中的所有状态和信息。</li><li>compilataion：编辑代码期间触发，可用于监听编译过程或编译处理错误</li><li>emit：输出文件之前触发，修改输出文件或者生成一些附件文件。</li><li>after-emit：输出文件后触发，用于清理中间文件</li><li>done：构建完成时触发，用于生成构建报告。</li></ul></blockquote><p>事件机制<br>Webpack采用事件驱动的方式打包web应用，其事件机制主要依靠一个很小的<strong>核心库tapable来实现</strong>。封装了事件订阅发布机制。compile、compilataion 都是tapable类的实例对象，</p><h2 id="webpack5-相比于-webpack4-有哪些提升？"><a href="#webpack5-相比于-webpack4-有哪些提升？" class="headerlink" title="webpack5 相比于 webpack4 有哪些提升？"></a>webpack5 相比于 webpack4 有哪些提升？</h2><ul><li>更快的构建速度，尤其是开发模式下构建速度明显的提升</li><li>Tree Shaking：优化算法。更准确哪些代码无用，更好的优化构建输出的文件大小</li><li>内置的持久化缓存：可以缓存每个模块编译结果，加速后续构建，</li><li>支持 WebAssmbly</li><li>模块联班：Module federation 解决模块共享、远程加载。为微前端架构提供支持。</li></ul><h2 id="对模块联班的理解"><a href="#对模块联班的理解" class="headerlink" title="对模块联班的理解"></a>对模块联班的理解</h2><p>模块联邦（Module Federation）是 Webpack 5 推出的一个新特性。它是一种模块共用机制，允许本地调用远程的模块。通过模块联邦可以解决微前端依赖问题，对比 npm 库具有实时性的优势。</p><h2 id="Webpack-中有哪些核心概念？"><a href="#Webpack-中有哪些核心概念？" class="headerlink" title="Webpack 中有哪些核心概念？"></a>Webpack 中有哪些核心概念？</h2><p>Webpack 中有以下几个核心概念：</p><ol><li>模块：Webpack 会将各种资源（如 JavaScript、CSS、图像等）视为模块。</li><li>入口：指定 Webpack 开始构建的起点。</li><li>输出：定义了最终生成的文件。</li><li>加载器：用于处理特定类型的文件。</li><li>插件：扩展 Webpack 的功能。</li><li>依赖关系：模块之间的依赖关系。</li><li>模块解析：确定如何查找和加载模块。</li><li>代码分割：将代码分割成多个块，按需加载。</li><li>优化：例如压缩、合并等，提高性能。</li><li>热更新：在运行时自动更新变更的模块。</li></ol><h2 id="webpack-的mode是什么？"><a href="#webpack-的mode是什么？" class="headerlink" title="webpack 的mode是什么？"></a>webpack 的mode是什么？</h2><p>Webpack 的 mode 提供了 mode 配置选项，告知 Webpack 使用相应模式的内置优化。mode 的值可以是 <strong>development、production 或 none</strong>，分别代表开发模式、生产模式和无预设模式（需要从头开始配置）。如果 mode 没有被设置，系统会默认使用 production 模式。</p><ol><li>development（开发模式）：提供了一些有助于开发和调试的特性，更详细的错误信息和警告。实时重新加载。 未压缩的代码以提高调试效率。</li><li>production（生产模式）：用于准备上线的构建，强调优化和性能：代码压缩和混淆。 资源优化。</li><li>none (无预设模式) 关闭任何默认优化选项，只执行基本打包功能，不做任何额外处理。</li></ol><h2 id="什么是代码分割（code-Splitting），如何在webpack中实现？"><a href="#什么是代码分割（code-Splitting），如何在webpack中实现？" class="headerlink" title="什么是代码分割（code Splitting），如何在webpack中实现？"></a>什么是代码分割（code Splitting），如何在webpack中实现？</h2><p>代码分割是将一个应用程序的代码拆分成多个独立的块，以便可以按需加载。可以减少初始加载时间提高页面性能，在 Webpack 中配置实现代码分割，有以下多种方式：<br>1、入口起点配置：配置多个入口起点，不同部分打包成独立的代码块。<br>2、动态导入 （Dynamic import）:可以将模块作为单独的代码块按需加载，这样模块需要时才会下载执行，<br>3、使用 SplitChunksPlugin 插件来自动分割代码。自动拆分公共模块，并创建独立代码块，避免重启加载，提高缓存利用率。<br>4、使用 CommonsChunkPlugin 插件来提取公共模块。</p>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css浮动</title>
    <link href="/2023/10/17/css%E6%B5%AE%E5%8A%A8/"/>
    <url>/2023/10/17/css%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="浮动与清除浮动"><a href="#浮动与清除浮动" class="headerlink" title="浮动与清除浮动"></a>浮动与清除浮动</h1><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="float-属性的取值"><a href="#float-属性的取值" class="headerlink" title="float 属性的取值"></a>float 属性的取值</h3><ul><li>left：元素向左浮动</li><li>right：元素向右浮动</li><li>none：默认值，元素不会浮动，并会显示在其文本中出现的位置</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对其进行环绕；</li><li>不管一个元素是行内元素还是块级元素，只要被设置了浮动，那浮动元素就会形成一个块级框，可以设置它的宽度和高度，因此浮动元素常常用于制作横向配列的菜单，可以设置大小并且横向排列。</li></ul><h3 id="浮动元素的展示在不同情况下会有不同的规则"><a href="#浮动元素的展示在不同情况下会有不同的规则" class="headerlink" title="浮动元素的展示在不同情况下会有不同的规则"></a>浮动元素的展示在不同情况下会有不同的规则</h3><ul><li>浮动元素在浮动的时候，其 margin 不会超过包含块的 padding</li><li>如果两个元素一个向左浮动，一个向右浮动，左浮动元素的 margin-right 不会和右元素的 margin-left 相邻</li><li>如果有多个浮动元素，浮动元素会按顺序排下来而不会发生重叠</li><li>如果有多个浮动元素，后面的元素高度不会超过前面的元素，并且不会超过包含块</li><li>如果有非浮动元素和浮动元素同时存在，并且非浮动元素在前，则浮动元素不会高于非浮动元素</li><li>浮动元素会尽可能地向顶端对齐、向左或向右对齐</li></ul><h3 id="重叠问题"><a href="#重叠问题" class="headerlink" title="重叠问题"></a>重叠问题</h3><ul><li>行内元素与浮动元素发生重叠，其边框、背景和内容都会显示在浮动元素之上</li><li>块级元素与浮动元素发生重叠时，边框和背景会显示在浮动元素之下，内容会显示在浮动元素之下</li></ul><h3 id="clear-属性"><a href="#clear-属性" class="headerlink" title="clear 属性"></a>clear 属性</h3><blockquote><p>  确保当前元素的左右两侧不会有浮动元素，clear 只对元素本身的布局起作用</p></blockquote><ul><li>left</li><li>right</li><li>both</li></ul><h2 id="父元素高度塌陷问题"><a href="#父元素高度塌陷问题" class="headerlink" title="父元素高度塌陷问题"></a>父元素高度塌陷问题</h2><blockquote><p>  为什么需要清除浮动</p></blockquote><p>一个块级元素如果没有设置高度，其高度是由子元素撑开的。如果对子元素设置了浮动，那么子元素就会脱离文档流，也就是说父元素没有内容可以撑开其高度，这样父级元素的高度就会被忽略，这就是所谓的高度塌陷。</p><h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ol><li><p>给父元素定义高度</p><ul><li>优点：操作简单</li><li>缺点：高度定死</li></ul></li><li><p>添加一个空元素 <code>&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; (.clear &#123; clear: both &#125;)</code></p><ul><li>优点：浏览器支持好</li><li>缺点：凭空多出很多无用空节点</li></ul></li><li><p>让父元素也一起浮动</p><ul><li>缺点：无法解决实际问题</li></ul></li><li><p>父元素设置为 <code>display: table</code></p><ul><li>缺点：会产生新的问题</li></ul></li><li><p>父元素设置 <code>overflow: hidden auto</code></p><ul><li>缺点：无法显示溢出的元素</li></ul></li><li><p>父元素伪元素设置清除浮动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  ...<br>&#125;<br><br><span class="hljs-selector-class">.father</span>:: after &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27; &#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">clear</span>: both;<br>  <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>float</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex 学习记录</title>
    <link href="/2023/10/12/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/10/12/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>今天在做项目的时候遇到一个关于布局的问题, 就是 <strong>flex: 1;</strong> 我一直以为 flex: 1; 代表的是 <strong>flex: auto;</strong> 后来发现结果并不是这样, 所以写一篇博客来讲解一下 flex: 1; 代表什么</p><h2 id="代码第一版"><a href="#代码第一版" class="headerlink" title="代码第一版"></a>代码第一版</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span>我是一个div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span>我是一个很多字div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span>我是一个更多字而且第三个div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.div</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br><span class="language-css">  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-8cc589398d0576b41e365af19b9e9325_r.jpg"></p><p>利用 <strong>flex: 1; 确实实现了三个不同内容的 div 平分空间, 所以按我以前的想法来说:</strong></p><blockquote><p><strong>flex: 1; &#x3D;&#x3D;&#x3D; flex: 1 1 auto;</strong></p></blockquote><p>这是完整写法, 详见**<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex">mdn</a>**, 它还有另外两种完整写法, 分别是 <strong>initial (0 1 auto)</strong> 和 <strong>none (0 0 auto)</strong></p><ul><li>第一个参数表示: <strong>flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</strong></li><li>第二个参数表示: <strong>flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</strong></li><li>第三个参数表示: <strong>flex-basis</strong> <strong>给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小</strong></li></ul><h2 id="代码第二版"><a href="#代码第二版" class="headerlink" title="代码第二版"></a>代码第二版</h2><p>上面证实了我以前的想法, flex:1; 就是代表均匀分配元素, 但是我们来改成完整写法看看</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 其他代码没有变化, 沿用上面的 */</span><br><br><span class="hljs-selector-class">.div</span>&#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> auto; <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-c52fab6fae7537b9223b28d786bb4d3c_r.jpg"></p><p>加入原来以为正确的完整代码后可以看到三个元素没有<strong>均分</strong>, 所以可以推出:</p><blockquote><p><strong>flex: 1; !&#x3D;&#x3D; flex: 1 1 auto;</strong></p></blockquote><p><strong>走到这我就一头雾水, 为什么和我以前想的完全不同, 于是我就去参照了 <a href="https://www.w3.org/TR/css-flexbox-1/#flex-common">w3c</a></strong> <strong>对于 flex 的解释, 官方明确指, flex 最后一个参数为 0, 见下图</strong></p><p><img src="/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-c1a91d2970defbd29c6fd9e897f9414c_r.jpg"></p><p><strong>所以:</strong></p><ul><li><strong>flex: 1; &#x3D;&#x3D;&#x3D; flex: 1 1 0;</strong></li></ul><p>但是在 chrome 浏览器上设置 flex: 1 1 0; 时, 它会自动加一个单位 px</p><p><img src="/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-679d29029cd5ac3996ac7f278e6d411d_r.jpg"></p><p>而设置 flex: 1; 时, 它会自动加一个 %, 看来他们解析到浏览器的时候必须带一个单位</p><p><img src="/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-533796bc14adcb110e2bc96e60330b55_r.jpg"></p><p>于是我就又做了几个实验, 改了一下 flex-basis 的参数, <strong>得出以下结论</strong></p><ul><li><strong>flex: 1; &#x3D;&#x3D;&#x3D; flex: 1 1 任意数字+任意长度单位;</strong></li></ul><p><strong>可以看出最重要的一点在 第三个参数 flex-basis 上, 我们再来回顾以下 这个属性的作用</strong></p><blockquote><p><strong>flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小</strong></p></blockquote><p>auto 为表示项目本身的大小, <strong>如果设置为 auto, 那么这三个盒子就会按照自己内容的多少来等比例的放大和缩小</strong>, 所以出现了上图中三个盒子不一样大的情况</p><p>那我们如果<strong>随便设置一个其他带有长度单位的数字</strong>呢, 那么他就不会按项目本身来计算, 所以它不关心内容, 只是把空间等比收缩和放大</p><p>现在你知道 flex: 1; 为什么能平分元素了吧, CSS 是一门很难学的语言, 虽然我经过不断试验得出结果, 但是它还有好多莫名其妙的问题去等你发现. 比如 <strong>margin: auto 为什么会实现居中, overflow: hidden 为何能实现 BFC</strong></p><p><strong>你可以遵从官方标准, 也可以和我一样去实验性的看待 flex: 1;</strong></p><p><strong>不过我建议你别深究这些问题, 因为所见即所得, 它这样能实现效果就可以了, CSS 学习是没必要刨根问底的, 会用就是最好的证明, 以上仅为个人见解, 如有疑问请给我留言或私信</strong></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css3</tag>
      
      <tag>flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github访问问题解决记录</title>
    <link href="/2023/07/27/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/07/27/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="解决-Github-port-443-Timed-out"><a href="#解决-Github-port-443-Timed-out" class="headerlink" title="解决 Github port 443 : Timed out"></a>解决 Github port 443 : Timed out</h1><p>Failed to connect to <a href="http://github.com/">github.com</a> port 443 : Timed out</p><h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>如下图所示，无法 git clone 来自 Github 上的仓库，报端口 443 错误</p><p><img src="/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/v2-3b264466dfeec3e70ff0534c35da18c2_r.jpg"></p><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><p>Git 所设端口与系统代理不一致，需重新设置</p><h2 id="三、解决方法"><a href="#三、解决方法" class="headerlink" title="三、解决方法"></a>三、解决方法</h2><h3 id="3-1、打开代理页面"><a href="#3-1、打开代理页面" class="headerlink" title="3-1、打开代理页面"></a>3-1、打开代理页面</h3><p>打开 设置 –&gt; 网络与Internet –&gt; 查找代理</p><p><img src="/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/v2-baceb7a931e8f13ff5b0956a68955639_b.gif"></p><p>记录下当前系统代理的 IP 地址和端口号</p><p>如上图所示，地址与端口号为：127.0.0.1:7890</p><p>可以尝试直接关闭设置内的系统代理，如果无效再修改git网络设置</p><h3 id="3-2、修改-Git-的网络设置"><a href="#3-2、修改-Git-的网络设置" class="headerlink" title="3-2、修改 Git 的网络设置"></a>3-2、修改 Git 的网络设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意修改成自己的IP和端口号</span><br>git config --global http.proxy http://127.0.0.1:7890 <br>git config --global https.proxy http://127.0.0.1:7890<br></code></pre></td></tr></table></figure><p><img src="/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/v2-32f6f2e6e7ea50f9de6f9aa35bd56dcd_r.jpg"></p><h2 id="四、完结撒花"><a href="#四、完结撒花" class="headerlink" title="四、完结撒花"></a>四、完结撒花</h2><p>可以重新 clone 尝试了（其实主要解决的是为啥搭建了梯子依旧不好使的问题，哈哈哈）</p><h2 id="五、后记"><a href="#五、后记" class="headerlink" title="五、后记"></a>五、后记</h2><p>当我们访问GitHub的时候一般都会使用梯子，所以往上推代码的时候也是需要梯子，没有梯子推送成功概率很低，一般都会报错超时，所以设置梯子提高访问成功率；</p><p>取消代理是因为，访问 Gitee 或其它是不需要梯子，所以要取消代理；或者后悔设置代理了，也可以利用此取消</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 取消代理</span><br>git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br><br><span class="hljs-comment"># 查看代理</span><br>git config --global --get http.proxy<br>git config --global --get https.proxy<br></code></pre></td></tr></table></figure><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/636418854">解决 Github port 443 : Timed out - 知乎</a></p><h1 id="OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="OpenSSL SSL_read: Connection was reset, errno 10054"></a>OpenSSL SSL_read: Connection was reset, errno 10054</h1><p>问题场景：之前关联的github库没办法上传（push）了，提示本地库不存在。于是做了</p><p>git init &#x2F;&#x2F;初始化资源库</p><p><strong>git remote</strong>-v origin https:<strong>&#x2F;&#x2F;</strong><a href="http://github.com/">http://github.com/</a>我的库 &#x2F;&#x2F;将本地库与远程库做关联，</p><p>git pull 先将线上的资源拉取下来。</p><p>问题出在了git pull的时候，提示错误</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">fatal: unable to access &#x27;http://github.com/我的库/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054<br></code></pre></td></tr></table></figure><p>报错原因：</p><p>字面意思：服务器的<a href="https://so.csdn.net/so/search?q=SSL&spm=1001.2101.3001.7020">SSL</a>证书灭有经过第三方机构的签署。</p><p>网上信息也有的说可能是网络不稳定，连接超时导致。</p><p>解决办法：</p><p>1.修改设置，解除SSL验证。打开 <a href="https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E8%A1%8C&spm=1001.2101.3001.7020">命令行</a>工具， 输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global http.sslVerify &quot;false&quot;<br>git config --global https.sslVerify &quot;false&quot;<br></code></pre></td></tr></table></figure><p>2、打开本地仓库的.git文件夹下的config文件</p><p>可以看到如下配置：</p><p><img src="/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/v2-a2dca06821dc763f84f6dad814011606_r.jpg"></p><p>配置文件</p><p>3、git pull 成功</p><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/492983195">OpenSSL SSL_read: Connection was reset, errno 10054 - 知乎</a></p><h1 id="使用-git-进行-push-时几乎无法连接"><a href="#使用-git-进行-push-时几乎无法连接" class="headerlink" title="使用 git 进行 push 时几乎无法连接"></a>使用 git 进行 push 时几乎无法连接</h1><p><img src="/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/%E5%9B%BE%E7%89%87_20230727151609-bak.png" alt="图片_20230727151609-bak"></p><p>原文链接：<a href="https://www.v2ex.com/t/819005">使用 git 进行 push 时几乎无法连接 - V2EX</a></p>]]></content>
    
    
    <categories>
      
      <category>日常问题解决记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>git</tag>
      
      <tag>timeout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo结合GitHubPage自定义域名开启Https</title>
    <link href="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/"/>
    <url>/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li>购买阿里云域名</li><li>注册<a href="https://app.netlify.com/">netlify</a>账号</li><li>博客搭建参考：<a href="https://reclusew.github.io/2021/08/12/blog-setup/">将博客部署到GitHubPage</a></li></ol><h1 id="HTTPS设置"><a href="#HTTPS设置" class="headerlink" title="HTTPS设置"></a>HTTPS设置</h1><p>HTTPS 的好处：</p><ul><li>保护用户的隐私信息安全：在 HTTP 网站数据以明文方式传输，客户的隐私极容易被盗取和泄露，而部署 SSL 证书，数据以 HTTPS 加密传输，可以保护通信不被第三方监听和窃取，从而保护用户隐私及安全。还可增加用户信任感和提升企业形象。</li><li>保护网站的安全性和完整性：HTTPS 是安全套接层超文本传输协议，可以保证网站的信息从用户浏览器到服务器之间的传输是高强度加密传输的，是不会被第三方窃取和篡改的，还能避免网站被劫持而插入广告等，防止被钓鱼网站攻击，从而保护网站的安全性和完整性</li><li>防止被钓鱼网站攻击，有效识别网站真实身份：http 网站会被浏览器标记 “不安全”，而安装 https 证书会取消这种 “不安全” 的警告，能增加访客信任度。同时对于安装了 OV SSL 证书或 EV SSL 证书的网站，还能向用户证明网站的真实身份，防止网站被钓鱼网站仿冒。</li></ul><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="设置Github仓库"><a href="#设置Github仓库" class="headerlink" title="设置Github仓库"></a>设置Github仓库</h3><p>进入部署仓库Settings -&gt; Pages -&gt; Custom domain，如图所示，同时开启<code>Enforce HTTPS</code></p><p><img src="/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726162422169.png" alt="image-20230726162422169"></p><h3 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>按照图示设置</p><p><img src="/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726163106611.png" alt="image-20230726163106611"></p><h3 id="设置完毕"><a href="#设置完毕" class="headerlink" title="设置完毕"></a>设置完毕</h3><p>设置完毕之后显示如图，虽然已经开启开启HTTPS但是浏览器依然显示不安全，故有方法二使用Netlify优化HTTPS</p><p><img src="/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726161257464.png" alt="image-20230726161257464"></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="Netlify简介"><a href="#Netlify简介" class="headerlink" title="Netlify简介"></a>Netlify简介</h3><ul><li>可以使用 CLI 上传代码</li><li>支持自定义域名且自定义域名支持一键开启 https（证书来自 Let’s Encrype）</li><li>支持强制让用户通过 https 访问网站（开启后此功能后，http 的访问一律会 301 跳转到 https</li><li>支持自动构建</li><li>支持重定向（Redirects）和重写（Rewrites）功能</li><li>数据通过 HTTP2 协议传输</li><li>提供 webhooks 与 API</li></ul><h3 id="Netlify使用"><a href="#Netlify使用" class="headerlink" title="Netlify使用"></a>Netlify使用</h3><h4 id="1-创建网页-，选择Import-an-existing-project"><a href="#1-创建网页-，选择Import-an-existing-project" class="headerlink" title="1. 创建网页 ，选择Import an existing project"></a>1. 创建网页 ，选择Import an existing project</h4><p><img src="/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726163946968.png" alt="image-20230726163946968"></p><h4 id="2-导入项目，选择Deploy-with-GitHub，选择相应的仓库等待构建完成即可"><a href="#2-导入项目，选择Deploy-with-GitHub，选择相应的仓库等待构建完成即可" class="headerlink" title="2. 导入项目，选择Deploy with GitHub，选择相应的仓库等待构建完成即可"></a>2. 导入项目，选择Deploy with GitHub，选择相应的仓库等待构建完成即可</h4><p><img src="/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726164239295.png" alt="image-20230726164239295"></p><h4 id="3-设置自定义域名"><a href="#3-设置自定义域名" class="headerlink" title="3. 设置自定义域名"></a>3. 设置自定义域名</h4><p>按图中步骤设置域名即可</p><p><img src="/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726164630063.png" alt="image-20230726164630063"></p><h4 id="4-阿里云域名解析设置"><a href="#4-阿里云域名解析设置" class="headerlink" title="4. 阿里云域名解析设置"></a>4. 阿里云域名解析设置</h4><p>此步骤与 <strong>方法一</strong> 中的<strong>设置解析域名</strong>基本一致，记录值替换为 **Netlify **提供的地址即可<img src="/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726164837226.png" alt="image-20230726164837226"></p><h4 id="5-开启HTTPS"><a href="#5-开启HTTPS" class="headerlink" title="5. 开启HTTPS"></a>5. 开启HTTPS</h4><p><img src="/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726165139140.png" alt="image-20230726165139140"></p><h3 id="设置完毕-1"><a href="#设置完毕-1" class="headerlink" title="设置完毕"></a>设置完毕</h3><p>显示如下，HTTPS已开启</p><p><img src="/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726165523754.png" alt="image-20230726165523754"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>推荐方法二，使用Netlify配置</p><br /><br /><p>参考链接：</p><p>[1]. <a href="https://cloud.tencent.com/developer/article/1964351">Hexo博客自定义域名开启HTTPS-腾讯云开发者社区-腾讯云</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHubPages</tag>
      
      <tag>Https</tag>
      
      <tag>自定义域名</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2双端diff算法学习</title>
    <link href="/2023/07/25/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/25/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>Vue2 的双端 diff 算法学习。</p><p>篇幅原因，本文并不会介绍虚拟 DOM 树是如何生成的，仅讲解在数据更新时，是如何比较两颗虚拟 DOM 树并更新真实 DOM 的，主要实现 Vue2 源码中的 <code>patchVnode</code>、<code>updateChildren</code> 函数</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="diff-算法作用"><a href="#diff-算法作用" class="headerlink" title="diff 算法作用"></a>diff 算法作用</h2><p>聊 diff 算法前得认识一下它是干嘛的。</p><p>我们知道在网页运行中，我们改变一些数据，它们可能会影响到 DOM 树。如何在页面中展示最新的数据呢，最简单的方式就是整棵树推到重建，当然这样会导致大量的浪费，所以 Vue 使用虚拟 DOM 保存页面中 DOM 树的状态，在数据变化后，构建一棵新的虚拟 DOM 树，找到前后两颗树的不同之处，针对性地更新真实 DOM。</p><p>而如何找到两颗树的不同之处，减少 DOM 元素的销毁与重建，就是 diff 算法的作用</p><h2 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h2><p>虚拟 DOM，又称虚拟节点(vnode)，简单来说就是包含 DOM 元素信息的对象，一般由 <code>h</code> 函数创建，下面这个对象就可以看成是一个虚拟节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-comment">// 标签类型</span><br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 文本内容</span><br>    <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 子节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于这段 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>转换成 vnode 是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-comment">// 标签类型</span><br>    <span class="hljs-attr">text</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 文本内容</span><br>    <span class="hljs-attr">children</span>: [ <span class="hljs-comment">// 子节点</span><br>        &#123;<br>            <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;p&#x27;</span>,<br>            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>            <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;p&#x27;</span>,<br>            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>            <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;p&#x27;</span>,<br>            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;c&#x27;</span>,<br>            <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>,<br>        &#125;,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们需要通过虚拟节点去操作真实 DOM，所以 vnode 身上有个 elm 属性指向真实的 DOM 元素。而且在之后的 diff 算法中，还会用到一个 key 来对节点进行唯一标识，所以下文中的 vnode 是这样的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-comment">// 标签类型</span><br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 文本内容</span><br>    <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 子节点</span><br>    <span class="hljs-attr">elm</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 对应的真实DOM</span><br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 唯一标识</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Vue 的虚拟节点还有很多属性，不过与 diff 算法无关，就不列举了</p><blockquote><p>说明一点，虚拟节点的 text 和 children 不会同时有值。在有 children 属性的情况下，text 中的内容会转化为一个文本节点置入 children 数组中</p></blockquote><h2 id="预备函数"><a href="#预备函数" class="headerlink" title="预备函数"></a>预备函数</h2><p>为了使等会的代码实现更简单，我们准备几个函数，功能不难，直接贴代码了</p><p>我们首先需要就是一个将虚拟节点转换为真实 DOM 的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 根据虚拟节点创建真实节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">vnode</span>) &#123;<br>    <span class="hljs-keyword">const</span> dom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>)<br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">children</span>) &#123;<br>        <span class="hljs-comment">// 包含子节点，递归创建</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; vnode.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">const</span> childDom = <span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">children</span>[i])<br>            dom.<span class="hljs-title function_">appendChild</span>(childDom)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 内部是文字</span><br>        dom.<span class="hljs-property">innerHTML</span> = vnode.<span class="hljs-property">text</span><br>    &#125;<br>    <span class="hljs-comment">// 补充elm属性</span><br>    vnode.<span class="hljs-property">elm</span> = dom<br>    <span class="hljs-keyword">return</span> dom<br>&#125;<br></code></pre></td></tr></table></figure><p>以及三个工具函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断是否未定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isUndef</span>(<span class="hljs-params">v</span>) &#123;<br>    <span class="hljs-keyword">return</span> v === <span class="hljs-literal">undefined</span> || v === <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-comment">// 判断是否已定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isDef</span>(<span class="hljs-params">v</span>) &#123;<br>    <span class="hljs-keyword">return</span> v !== <span class="hljs-literal">undefined</span> &amp;&amp; v !== <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-comment">// 检查是否可复用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkSameVnode</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-property">tag</span> === b.<span class="hljs-property">tag</span> &amp;&amp; a.<span class="hljs-property">key</span> === b.<span class="hljs-property">key</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h1><p>当数据更新后，Vue 创建出一棵新 vnode，然后执行 <code>patchVnode</code> 函数比较新老两个虚拟节点的不同之处，然后根据情况进行处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchVnode</span>(<span class="hljs-params">newVnode, oldVnode</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>首先判断新旧两个虚拟节点是同一对象，如果是的话就不用处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (oldVnode === newVnode) <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>然后将旧节点的 DOM 元素赋给新节点，并获取新旧节点的 children 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> elm = (newVnode.<span class="hljs-property">elm</span> = oldVnode.<span class="hljs-property">elm</span>)<br><span class="hljs-keyword">let</span> oldCh = oldVnode.<span class="hljs-property">children</span><br><span class="hljs-keyword">let</span> newCh = newVnode.<span class="hljs-property">children</span><br></code></pre></td></tr></table></figure><p>这里可以直接赋值是因为调用 patchVnode 的新旧节点它们的 tag 与 key 是一定相同的，在下文会有讲解</p><p>然后根据两个节点内容，决定如何更新 DOM</p><ol><li>新旧两个节点内容都是文本。修改文本即可</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isUndef</span>(newCh)) &#123;<br>    <span class="hljs-keyword">if</span> (newVnode.<span class="hljs-property">text</span> !== oldVnode.<span class="hljs-property">text</span>) &#123;<br>        elm.<span class="hljs-property">innerText</span> = newVnode.<span class="hljs-property">text</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>旧节点有子节点，新节点内容是文本。清空旧节点内容，改为文本</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isUndef</span>(newCh)) &#123;<br>    elm.<span class="hljs-property">innerHTML</span> = newVnode.<span class="hljs-property">text</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>旧节点内容是文本，新节点有子节点。清空旧节点内容，遍历新节点生成子 DOM 元素插入节点中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isDef</span>(newCh)) &#123;<br>    elm.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, n = newCh.<span class="hljs-property">length</span>; i &lt; n; i++)&#123;<br>        elm.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">createElement</span>(newCh[i]))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>新旧节点都有子节点。调用 <code>updateChildren</code> 来处理，该函数在下一章讲解</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isDef</span>(newCh)) &#123;<br>    <span class="hljs-title function_">updateChildren</span>(elm, oldCh, newCh)<br>&#125;<br></code></pre></td></tr></table></figure><p>情况 4 可以与情况 3 的处理一样，清空旧节点，然后遍历生成新 DOM。但是我们要知道，创建 DOM 元素是一件非常耗时的工作，而且新旧子节点在大多时候都是相同的，如果可以复用，将极大优化我们的性能。</p><p>那我们要如何判定一个节点是否可以复用呢？</p><p>这就需要 Vue 的使用者来帮忙了，使用者在节点上定义 key 属性，告诉 Vue 哪些节点可以复用</p><p><strong>只要标签类型与 key 值都相等，就说明当前元素可以被复用</strong></p><p>然而在我们的项目中，一般只有在 v-for 中才设置 key，其他节点都没设置 key</p><p>其实<strong>没有设置 key 的节点，它们的 key 值默认相等</strong></p><p>事实也是如此，我们项目中大部分元素都可以复用，只有 v-for 生成的子元素，它依赖的数组可能发生一些较复杂的变化，所以才需要明确标注 key 值，以帮助 Vue 尽可能地复用节点。</p><blockquote><p>patchVnode 的内容当然不止这些，还有样式、类名、props等数据的对比更换，篇幅原因本文将其省略了。</p></blockquote><h1 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h1><h2 id="为什么采用双端-diff"><a href="#为什么采用双端-diff" class="headerlink" title="为什么采用双端 diff"></a>为什么采用双端 diff</h2><p>好了，Vue 的使用者为每个节点的设置了 key，我们要如何从老节点中找到 key 相等的节点复用元素呢？</p><p>简单的方式就是穷举遍历，对于每个新节点的 key 遍历所有老节点，找到了就移动到首位，没找到就创建添加。</p><p>然而这明显有优化的空间，Vue 实现这部分功能时借鉴了 snabbdom 的双端 diff 算法，因为此算法将我们平时操作数组常见的 4 种情况抽离了出来，涵盖了我们业务中的大多数场景，将 O(n<sup>2</sup>) 的时间复杂度降到了 O(n)</p><p>接下来我们来学习这是如何实现的</p><h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><p>函数实现较为复杂，我直接把完整的代码放上来，再带领大家一段段解读</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 三个参数为：父DOM元素，旧的子节点数组，新的子节点数组</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span>(<span class="hljs-params">parentElm, oldCh, newCh</span>) &#123;<br>    <span class="hljs-comment">// 旧前索引</span><br>    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 新前索引</span><br>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 旧后索引</span><br>    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 新后索引</span><br>    <span class="hljs-keyword">let</span> newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 四个索引对应节点</span><br>    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]<br>    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx]<br><br>    <span class="hljs-keyword">let</span> keyMap<br><br>    <span class="hljs-comment">// 开始循环</span><br>    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>        <span class="hljs-comment">// 跳过空节点 (和最后一种情况有关)</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldStartVnode)) &#123;<br>            oldStartVnode = oldCh[++oldStartIdx]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldEndVnode)) &#123;<br>            oldEndVnode = oldCh[--oldEndIdx]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">checkSameVnode</span>(oldStartVnode, newStartVnode)) &#123;<br>            <span class="hljs-comment">// 情况1</span><br>            <span class="hljs-comment">// 旧前和新前相等，不需要移动</span><br>            <span class="hljs-title function_">patchVnode</span>(newStartVnode, oldStartVnode)<br>            oldStartVnode = oldCh[++oldStartIdx]<br>            newStartVnode = newCh[++newStartIdx]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">checkSameVnode</span>(oldEndVnode, newEndVnode)) &#123;<br>            <span class="hljs-comment">// 情况2</span><br>            <span class="hljs-comment">// 旧后和新后相等，也不需要移动</span><br>            <span class="hljs-title function_">patchVnode</span>(newEndVnode, oldEndVnode)<br>            oldEndVnode = oldCh[--oldEndIdx]<br>            newEndVnode = newCh[--newEndIdx]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">checkSameVnode</span>(oldStartVnode, newEndVnode)) &#123;<br>            <span class="hljs-comment">// 情况3</span><br>            <span class="hljs-comment">// 旧前和新后相等</span><br>            <span class="hljs-comment">// 旧序列的第一个节点，变成了新序列的最后一个节点</span><br>            <span class="hljs-comment">// 需要将这个节点移动到旧序列最后一个节点的后面</span><br>            <span class="hljs-comment">// 也就是最后一个节点的下一个节点的前面</span><br>            parentElm.<span class="hljs-title function_">insertBefore</span>(oldStartVnode.<span class="hljs-property">elm</span>, oldEndVnode.<span class="hljs-property">elm</span>.<span class="hljs-property">nextSibling</span>)<br>            <span class="hljs-title function_">patchVnode</span>(newEndVnode, oldStartVnode)<br>            oldStartVnode = oldCh[++oldStartIdx]<br>            newEndVnode = newCh[--newEndIdx]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">checkSameVnode</span>(oldEndVnode, newStartVnode)) &#123;<br>            <span class="hljs-comment">// 情况4</span><br>            <span class="hljs-comment">// 旧后和新前相等</span><br>            <span class="hljs-comment">// 旧序列的最后一个节点，变成了新序列的第一个节点</span><br>            <span class="hljs-comment">// 需要将这个节点移动到旧序列第一个节点的前面</span><br>            parentElm.<span class="hljs-title function_">insertBefore</span>(oldEndVnode.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)<br>            <span class="hljs-title function_">patchVnode</span>(newStartVnode, oldEndVnode)<br>            oldEndVnode = oldCh[--oldEndIdx]<br>            newStartVnode = newCh[++newStartIdx]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 以上四种情况都不符合</span><br>            <span class="hljs-comment">// 制作旧节点key的映射对象</span><br>            <span class="hljs-comment">// 键为 key，值为 索引</span><br>            <span class="hljs-keyword">if</span> (!keyMap) &#123;<br>                keyMap = &#123;&#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;<br>                    keyMap[oldCh[i].<span class="hljs-property">key</span>] = i<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 寻找当前新节点在keyMap中映射的位置序号</span><br>            <span class="hljs-keyword">const</span> idxInOld = keyMap[newStartVnode.<span class="hljs-property">key</span>]<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(idxInOld)) &#123;<br>                <span class="hljs-comment">// 没有找到，表示他是全新的项</span><br>                <span class="hljs-comment">// 转化为DOM节点，加入旧序列第一个节点的前面</span><br>                parentElm.<span class="hljs-title function_">insertBefore</span>(<span class="hljs-title function_">createElement</span>(newStartVnode), oldStartVnode.<span class="hljs-property">elm</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 不是全新的项，需要移动</span><br>                <span class="hljs-keyword">const</span> oldVnode = oldCh[idxInOld]<br>                <span class="hljs-comment">// 移动到旧序列第一个节点之前</span><br>                parentElm.<span class="hljs-title function_">insertBefore</span>(oldVnode.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)<br>                <span class="hljs-title function_">patchVnode</span>(oldVnode, newStartVnode)<br>                <span class="hljs-comment">// 把这项设置成空，循环时遇到时跳过</span><br>                oldCh[idxInOld] = <span class="hljs-literal">undefined</span><br>            &#125;<br>            <span class="hljs-comment">// 当前新节点处理完毕，下一轮循环处理下一个新节点</span><br>            newStartVnode = newCh[++newStartIdx]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 循环结束了，start还是比end小，说明有节点没有处理到</span><br>    <span class="hljs-keyword">if</span> (newStartIdx &lt;= newEndIdx) &#123;<br>        <span class="hljs-comment">// 新节点没有处理到，则创建按DOM添加到新序列最后一个节点的前面</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;<br>            <span class="hljs-comment">// insertBefore方法传入null则添加到队尾</span><br>            <span class="hljs-keyword">const</span> before = newCh[newEndIdx + <span class="hljs-number">1</span>]?.<span class="hljs-property">elm</span> || <span class="hljs-literal">null</span><br>            parentElm.<span class="hljs-title function_">insertBefore</span>(<span class="hljs-title function_">createElement</span>(newCh[i]), before)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldStartIdx &lt;= oldEndIdx) &#123;<br>        <span class="hljs-comment">// 旧节点没有处理到，删除</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;<br>            parentElm.<span class="hljs-title function_">removeChild</span>(oldCh[i].<span class="hljs-property">elm</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码注释中及下文的新&#x2F;旧<strong>序列</strong>，仅包含从新&#x2F;旧<strong>开始索引到结束索引间的节点</strong>，也就是还未处理的节点序列，而不是整个子节点数组。</p></blockquote><h2 id="根据例子讲解"><a href="#根据例子讲解" class="headerlink" title="根据例子讲解"></a>根据例子讲解</h2><p>我们以下图的例子，来讲解这个函数的运行流程（方框中的内容为子节点的 key，所有节点标签相同）</p><p>首先定义了 8 个变量，表示新旧序列的开始和结束位置的索引与节点</p><p><img src="/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/10c92251651c4cc28f556696661d597btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>然后开始循环，初始时节点都不为空</p><p><strong>第一次循环命中情况 1，旧前与新前(key)相等</strong></p><p>这表示旧序列的第一个节点到新序列仍是第一个节点，也就不需要移动，但还需要比较一下节点的内容有没有改变(patchVnode)，并且让新旧开始索引都前进一步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 比较节点的数据及子节点，并且将旧节点的DOM赋给新节点</span><br><span class="hljs-title function_">patchVnode</span>(newStartVnode, oldStartVnode)<br>oldStartVnode = oldCh[++oldStartIdx]<br>newStartVnode = newCh[++newStartIdx]<br></code></pre></td></tr></table></figure><p><img src="/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/48585f8d2ded4db7bc73b5b566b811c1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>情况 1 是业务中最常见的，表示从前至后两两比较。一般把商品添加到购物车末尾，或是没有设置 key 值的子节点，都是依靠情况 1 把可复用的节点筛选完毕。</p><p><strong>第二次循环命中情况 2，旧后和新后相等</strong></p><p>这表示序列的末尾节点到新序列仍是末尾节点，也不需要移动，然后让新旧结束索引都后退一步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">patchVnode</span>(newEndVnode, oldEndVnode)<br>oldEndVnode = oldCh[--oldEndIdx]<br>newEndVnode = newCh[--newEndIdx]<br></code></pre></td></tr></table></figure><p><img src="/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/417842734e2b4209870a8717f4452079tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>情况 2 是情况 1 的补充，表示从后向前两两比较。有时会把新发布的评论插到开头，或者从购物车删除了一些商品，这时仅依靠情况 1 就无法迅速的筛选可复用节点，所以需要从后向前比较来配合。</p><p><strong>第三次循环命中情况 3，旧前和新后相等</strong></p><p>这表示旧序列的第一个节点，变成了新序列的最后一个节点。需要将这个节点移动到序列的末尾，也就是旧序列末尾节点的下一个节点(节点 e)的前面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parentElm.<span class="hljs-title function_">insertBefore</span>(oldStartVnode.<span class="hljs-property">elm</span>, oldEndVnode.<span class="hljs-property">elm</span>.<span class="hljs-property">nextSibling</span>)<br></code></pre></td></tr></table></figure><p><img src="/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/8482cb53c49c4be7bf0ea64c306c8852tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>然后比较新旧节点，修改索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">patchVnode</span>(newEndVnode, oldStartVnode)<br>oldStartVnode = oldCh[++oldStartIdx]<br>newEndVnode = newCh[--newEndIdx]<br></code></pre></td></tr></table></figure><p><img src="/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/c11982331fb1458ba3725e4547d88fe4tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>情况 3 主要处理数组反转的情况，比如升序改降序，每个起始节点被移动到了末尾的位置，使用此情况将它们重新排序。</p><p><strong>第四次循环命中情况 4，旧后与新前相等</strong></p><p>这表示旧序列的最后一个节点，变成了新序列的第一个节点。需要将这个节点移动到序列的开头，也就是旧序列开始节点（节点 c）的前面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parentElm.<span class="hljs-title function_">insertBefore</span>(oldStartVnode.<span class="hljs-property">elm</span>, oldEndVnode.<span class="hljs-property">elm</span>.<span class="hljs-property">nextSibling</span>)<br></code></pre></td></tr></table></figure><p><img src="/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/4bcde48abb8c44b8931081e0eecd21b6tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>到这里说一下，图上标注的是节点 a 的后面，是因为节点 b 被移动到了末尾</p><p><strong>节点的移动都是根据旧节点来定位的，如果想把一个节点放到序列的开头，就放到旧序列开始节点的前面；如果想把一个节点放到序列的末尾，就要放到旧序列结束节点的下一个节点的前面</strong></p><p>然后也是比较新旧节点，修改索引，之后是下图情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">patchVnode</span>(newStartVnode, oldEndVnode)<br>oldEndVnode = oldCh[--oldEndIdx]<br>newStartVnode = newCh[++newStartIdx]<br></code></pre></td></tr></table></figure><p><img src="/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/c0298603a19645be9b2ac4ea6352b8aftplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>情况 4 是情况 3 的补充，避免反转数组后又插入&#x2F;删除了节点导致情况 3 无法匹配，本例就是这个情况。</p><p><strong>第五次循环，4 种情况均为未命中</strong></p><p>很遗憾，无法迅速锁定节点的位置，只能用传统的方式进行遍历</p><p>我们这里选择了以空间换时间的方式，定义了 keyMap，将旧序列节点的 key 与索引存起来，然后使用新开始节点的 key 去查找。</p><p>如果没找到，说明这是一个新节点，创建节点并放到开头，也就是插入到旧序列开始节点的前面</p><p>但如果找到了，则同样移动节点到序列开头，然后将对应的旧节点索引置空，在以后循环遇到空的旧节点就跳过了</p><p>本例中是未找到的情况，此节点处理完毕，新开始索引加一，超过了新结束索引，不满足循环条件，退出循环</p><p><img src="/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/e0e823d81bb94d63adff7cd69006e3f4tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>然而，节点 c 并没有被处理，此时的 DOM 序列为：a,d,f,c,b,e</p><p>所以在循环之后，要检测是否有未处理的节点，如果是旧节点未处理，删除即可；</p><p>如果是新节点未处理，则创建新节点插入到<strong>旧序列的末尾</strong>或者<strong>旧序列的开头</strong>，二者其实是一个位置</p><p>我们假设旧节点中没有 c，则在第四次循环后就会出现以下情况（第四次循环命中的是情况 1）</p><p><img src="/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/a31a7f766b8c48b78e4227d2ddb476f1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>如果把 f 放到序列的开头，就是旧开始节点（节点 e）的前面</p><p>而如果把 f 放到序列的末尾，也就是旧结束节点的下一个节点（节点 e）的前面</p><p>此时旧序列就是一个点，不分开头和结尾，只要保证新增节点序列按序添加就好了</p><p>至此，双端 diff 算法就讲完了</p><h1 id="Vue-中的-key"><a href="#Vue-中的-key" class="headerlink" title="Vue 中的 key"></a>Vue 中的 key</h1><p>学完 diff 算法，再聊聊 key 的作用</p><h2 id="v-for-中的-key"><a href="#v-for-中的-key" class="headerlink" title="v-for 中的 key"></a>v-for 中的 key</h2><p>上面讲的都是有 key 情况下，diff 算法能够迅速找到新旧序列中的同一节点，以较小的代价完成更新。</p><p>而如果在 v-for 中不设置 key 呢？</p><p>假设我们在数组头部插入了一个新节点，然后开始循环，每次循环都命中情况 1，尝试“复用”此节点。</p><p>但是，在对比新旧节点的内容时，都会发现内容不同，需要用新节点的内容替换旧节点。这只是复用了 DOM 的外壳，节点的内容、数据以及该节点的子节点全都要更改。</p><p>相比有 key 时的只添加一个新节点，无 key 则将所有节点都修改一遍。</p><h2 id="v-if-自带-key"><a href="#v-if-自带-key" class="headerlink" title="v-if 自带 key"></a>v-if 自带 key</h2><p>v-for 以外的元素我们一般是不设置 key 的，但是如果子元素中有 v-if 的话，就像下面这个场景（abcd是内容，并不是 key），更新子元素又会复现上一节的情况。</p><p><img src="/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/b182b8cc704f4e36b3c980d77a21e0betplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>然而 Vue 官方也考虑到了这点，会为 v-if 的元素加上利用 hash 函数生成的唯一 key</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以下出自 v2 源码</span><br><span class="hljs-keyword">var</span> needsKey = !!el.<span class="hljs-property">if</span> <br>……<br>needsKey ? <span class="hljs-string">&#x27;,null,false,&#x27;</span> + <span class="hljs-title function_">hash</span>(generatedSlots) : <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="key-的另一个用法"><a href="#key-的另一个用法" class="headerlink" title="key 的另一个用法"></a>key 的另一个用法</h2><p>顺便再提一嘴，key 可以绑到任意元素上，当 key 发生变化时，会导致 DOM 的销毁与重建，一般用来重复触发动画或生命周期钩子。</p><p>详情可看<a href="https://cn.vuejs.org/v2/api/#key">官方链接</a></p><br /><br /><p>参考：</p><p>[1]. <a href="https://juejin.cn/post/7120919895713251335">聊聊 Vue2 是如何更新节点的 | diff 算法详解 - 掘金 (juejin.cn)</a></p><p>[2]. <a href="https://segmentfault.com/a/1190000043632772#item-8">javascript - Vue2 diff 算法图解 - Vuejs源码解析 - SegmentFault 思否</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diff</tag>
      
      <tag>双端算法</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript原型与原型链学习</title>
    <link href="/2023/07/10/JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/10/JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>​JavaScript作为一个基于原型的OOP，和我们熟知的基于类的面向对象编程语言有很大的差异。如果不理解其中的本质含义，则无法深入理解JavaScript的诸多特性。</p><p>​在基于类的编程语言中，都要先抽象出一个“类”，用来统一表示同一种对象。然后用这个抽象类创建出一个个实例（泛化），也就是对象object。最后，类和类之间通过组合、继承等特性共建出一个可以互动的系统，从而用这套人为创建的系统来模拟、操纵现实中的物理世界。它的三大特性为：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p>然而，在原型概念中，有很多不同之处。基于原型的编程范式提倡程序设计者关注实例对象的一系列行为，然后根据行为的不同划分出不同的原型，而不是事先抽象出一个类，再关注具体的对象。它最大的特点是可以动态修改对象的行为，具有高度灵活性。</p><p>如果把基于类的对象称为“自上而下”式的顶层设计，那么基于原型的对象则可以被称为“自下而上”式的动态演化。</p><blockquote><p>基于原型的面向对象系统通过“复制”的方式来创建新对象，这实际上就是创建一个全新的对象。</p></blockquote><p>原型系统的“复制”操作有两种实现思路：</p><ul><li>并不是真正的复制一个对象，而是使新对象持有一个原型的引用；</li><li>切实的复制一个对象，复制对象和被复制对象再无任何关联。</li></ul><p><strong>原型链</strong></p><p>JavaScript的每个对象都有一个指向其原型对象的关系链，当试图访问一个属性时，它不仅仅在对象上搜寻，而且还会在它的原型上搜寻，以及原型的原型上搜寻，直到找到属性或者达到此链条的顶端，这就是JavaScript的原型链，用来实现继承的核心逻辑。</p><p>原型链经典图</p><p><img src="/JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AD%A6%E4%B9%A0/%E5%8E%9F%E5%9E%8B%E9%93%BE1.jpg" alt="原型链1"></p><p><img src="/JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AD%A6%E4%B9%A0/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%8F%E5%85%B8%E5%9B%BE.jpg" alt="原型链经典图"></p><p><strong>总结</strong></p><ul><li>牢记三点：<br> - __proto__属性是对象所独有的；</li></ul><p> - prototype属性是函数所独有的；</p><p> - 因为函数也是一种对象，所以同时拥有__proto__属性和prototype属性。</p><ul><li><p>__proto__属性的作用是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__所指向的那个对象里找，一直找，直到__proto__属性为null，再往上会报错，因为null没有原型。通过__proto__属性将对象的继承关系连接起来的这条链路即原型链。</p></li><li><p>prototype属性的作用是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Foo.prototype。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用Typora和GithubPages部署博客图片路径问题</title>
    <link href="/2023/02/17/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/17/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li><p>首先引用 hexo-renderer-marked 包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo-renderer-marked --save<br></code></pre></td></tr></table></figure></li><li><p>修改博客项目根目录下_config.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>    <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>开启了之后，图片资源就会自动解析成对应的图片路径。比如：“test.jpg” 位于 “&#x2F;2022&#x2F;04&#x2F;25&#x2F;test&#x2F;test.jpg”</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">!<span class="hljs-selector-attr">[]</span>(test.jpg)` 将会转换成 `&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;/2022/04/25/test/test.jpg&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li></ol><p>这种方式，虽然能解决发布之后图片展示的问题，但是不能解决本地typora编辑的问题，例如：有如下的目录结构：</p><blockquote><p><img src="/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/webp.webp" alt="img"></p></blockquote><p>编辑hexo-github.md文件，如果写成：</p><blockquote><p><img src="/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/webp-16766246268032.webp" alt="img"></p></blockquote><p>这种相对路径之后，能在typora中显示图片，但是在网页上就不能展示图片，如果改成下面这种：</p><blockquote><p><img src="/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/webp-16766246469994.webp" alt="img"></p></blockquote><p>能在网页上显示图片，但是在typora中又不能显示，这个时候，我们就通过修改插件 hexo-renderer-marked 的代码，来兼容两方的需求，找到图片路径转换的代码：</p><blockquote><p><img src="/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/webp-16766246706976.webp" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&gt;<span class="hljs-keyword">if</span> (href.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &gt; -<span class="hljs-number">1</span>) &#123;<br>   href = href.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">1</span>];<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><p>其中红框中的代码就是新加的，这样我们在md文件中，路径写成：<br>hexo-github&#x2F;image-20220423232811690.png 这样，就能同时在typora和网页上进行展示</p><p>最后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo clean<br>hexo g<br>hexo s<br>hexo d<br></code></pre></td></tr></table></figure><p>typora相关设置参考链接：<a href="https://www.bilibili.com/read/cv12633102/">2021最全hexo搭建博客+matery美化+使用（保姆级教程） - 哔哩哔哩</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>typora</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00Devtools前置知识</title>
    <link href="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Renderer-Process"><a href="#Renderer-Process" class="headerlink" title="Renderer Process"></a>Renderer Process</h1><blockquote><p>渲染器进程：Chrome 的多进程架构中，每打开一个 tab页 都会独立运行一个渲染器进程，从而保证某一 tab页 无响应或崩溃不会影响其他 tab页 的活动。</p></blockquote><h3 id="Chrome-中的进程与分工"><a href="#Chrome-中的进程与分工" class="headerlink" title="Chrome 中的进程与分工"></a><strong>Chrome 中的进程与分工</strong></h3><blockquote><p>![Chrome 中的进程与分工-](00Devtools前置知识&#x2F;Chrome 中的进程与分工-.png)</p></blockquote><ul><li><strong>浏览器进程（Browser Process）</strong>：控制 chrome 应用程序，包括地址栏、书签、后退和前进按钮。还处理 Web 浏览器的不可见的特权部分，例如网络请求和文件访问。</li><li><strong>渲染器进程（Renderer Process）</strong>：控制tab页中所有内容的显示。</li><li><strong>插件进程（Plugin Process）</strong>：控制网站使用的任何插件，例如 flash。</li><li><strong>图形处理器进程（GPU Process</strong>）：独立于其他进程处理 GPU 任务。</li></ul><h3 id="渲染器进程中的线程"><a href="#渲染器进程中的线程" class="headerlink" title="渲染器进程中的线程"></a><strong>渲染器进程中的线程</strong></h3><blockquote><p><strong>渲染器进程包含主线程（main thread）、工作线程（worker threads）、合成线程（compositor thread）和光栅线程（raster thread）。</strong></p><br><p><img src="/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E6%B8%B2%E6%9F%93%E5%99%A8%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B.png" alt="渲染器进程中的线程"></p></blockquote><h2 id="页面渲染步骤"><a href="#页面渲染步骤" class="headerlink" title="页面渲染步骤"></a>页面渲染步骤</h2><p>渲染器进程的核心工作是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，主要步骤如下：</p><h3 id="1-DOM-解析"><a href="#1-DOM-解析" class="headerlink" title="1.DOM 解析 "></a>1.DOM 解析 <em><Parsing></em></h3><p>渲染进程解析接收到的HTML数据并转化为DOM对象。</p><h3 id="2-样式计算"><a href="#2-样式计算" class="headerlink" title="2.样式计算 "></a>2.样式计算 <em><Stylecal Culation></em></h3><p>主线程根据 CSS 样式选择器计算出的每个DOM元素应具备的具体样式。</p><h3 id="3-布局"><a href="#3-布局" class="headerlink" title="3.布局 "></a>3.布局 <em><Layout></em></h3><p>经过上面的步骤虽然已经知道页面的具体文档结构以及每个节点拥有的样式信息，但仍然不能确定页面最终的样子。布局的过程是计算出每个节点的几何信息。</p><blockquote><p><strong>布局过程中主线程会遍历构建的DOM树，根据DOM节点的计算样式计算出一个布局树（layout tree）</strong></p><br><p><img src="/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/LayoutTree.png" alt="LayoutTree"></p><br><p>布局树上每个节点会有它在页面上的x，y坐标以及盒子大小（bounding box sizes）的具体信息。布局树与先前构建的DOM树差不多，不同的是只有那些可见的节点。</p></blockquote><h3 id="4-分层"><a href="#4-分层" class="headerlink" title="4.分层 "></a>4.分层 <em><Dividing into layers></em></h3><p>分层的作用确定哪些元素需要放置在哪一图层，此过程主线程会遍历布局树来创建一棵层次树（Layer Tree）。在DevTools中这一部分工作叫做 <code>Update Layer Tree</code>。分层与合成（Compositing）息息相关，在后面详细介绍。</p><blockquote><p><img src="/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%88%86%E5%B1%82.jpg" alt="分层"></p></blockquote><h3 id="5-绘制"><a href="#5-绘制" class="headerlink" title="5.绘制 "></a>5.绘制 <em><Paint></em></h3><p>有了 DOM、样式和布局信息仍不足以呈现页面。比如某些元素设置了<code>z-index</code>，仅按照 HTML 元素的顺序会导致渲染的结果不正确，所以还需要知道绘制的顺序。主线程会遍历之前的布局树（layout tree）来生成一系列的绘画记录（paint records），从而得到了绘制的顺序。</p><blockquote><p><img src="/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E7%BB%98%E5%88%B6.jpg" alt="绘制"></p></blockquote><h3 id="6-合成"><a href="#6-合成" class="headerlink" title="6.合成 "></a>6.合成 <em><Compositing></em></h3><p>经过上面的步骤，浏览器知道了文档结构、每个元素的样式、页面的几何形状和绘制顺序。浏览器就可以开始绘制页面。而将这些信息转化为显示器的像素的过程叫做 <strong>光栅化</strong>。 光栅化最简单的做法就是只光栅化视口内的内容。如果用户进行了页面滚动，就移动光栅帧（rastered frame）光栅化更多的内容以填充缺失的部分，最初的 Chrome 就是这么做的。对于现代的浏览器来说采取一种更加复杂的做法，叫做合成（compositing）。合成是一种将页面分成若干层，分别对它们进行光栅化，然后在一个单独的线程 — 合成线程（compositor thread）里合成为一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果。动画则可以通过移动图层并合成新帧以相同的方式实现。</p><h2 id="光栅化与合成"><a href="#光栅化与合成" class="headerlink" title="光栅化与合成"></a>光栅化与合成</h2><p>合成的过程类似 Photoshop 将多个图层按顺序叠加后导出最终的图片，图像发生变更也只需要调整对应的图层。合成的详细过程：</p><h3 id="1-分层"><a href="#1-分层" class="headerlink" title="1.  分层 "></a>1.  <strong>分层</strong> <em><Dividing into layers></em></h3><p>合成之前需要主线程先将页面分成若干层。为了确定哪些元素需要放置在哪一层，主线程需要遍历布局树来创建一棵层次树（Layer Tree），在DevTools中这一部分工作叫做 <code>Update Layer Tree</code>。</p><blockquote><p><img src="/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%89%E6%A0%85%E5%8C%96-%E5%88%86%E5%B1%82.jpg" alt="光栅化-分层"></p></blockquote><p>也可以使用 <code>will-change</code> CSS 属性告诉浏览器对其单独分层。你甚至可以给页面上所有的元素一个单独的层，但分层并不是越多越好，当页面的层数超过一定数量后，分层的合成操作会比在每帧中光栅化页面的一小部分还要慢。在 Frames 或 DevTools <code>Layers</code> 面板中可查看网站如何被分层</p><blockquote><p><img src="/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%89%E6%A0%85%E5%8C%96-%E5%88%86%E5%B1%822.jpg" alt="光栅化-分层2"></p><p><img src="/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%89%E6%A0%85%E5%8C%96-%E5%88%86%E5%B1%821.jpg" alt="光栅化-分层1"></p></blockquote><h3 id="2-光栅化分层"><a href="#2-光栅化分层" class="headerlink" title="2. 光栅化分层"></a>2. 光栅化分层</h3><p>光栅线程光栅化分层。一旦创建了<code>Layer Tree</code>并确定了绘制顺序，主线程就会向合成线程（compositor thread）提交这些信息。然后合成线程就会光栅化页面的每一层，因为页面的一层可能有整个网页那么大，所以合成器进程需要将它们切分为若干的切片然后将每个切片发送给光栅线程（raster thread），光栅线程会光栅化每个切片并且把它们存储在GPU的内存中。</p><blockquote><p><img src="/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%89%E6%A0%85%E5%8C%96-%E5%88%86%E5%B1%823.jpg" alt="光栅化-分层3"></p></blockquote><p>合成器进程可以对不同的光栅线程进行优先级排序，以便优先对视口内（或附近）的内容进行光栅化。</p><h3 id="3-合成"><a href="#3-合成" class="headerlink" title="3.  合成"></a>3.  合成</h3><p>对切片进行光栅化后，合成器线程会收集切片信息（draw quads）来构建一个合成帧（compositor frame）。</p><ul><li><code>draw quads</code>：包含切片在内存的位置以及图层合成后切片在页面的位置信息。</li><li><code>compositor frame</code>： 绘制一帧内容的 draw quads 集合。</li></ul><p>然后通过IPC将合成帧提交给浏览器进程（browser process）。此时 UI 线程或其他渲染器进程也可以添加另外的合成帧，这些合成帧被发送到 GPU 以显示在屏幕上。如果如果出现滚动事件，合成器线程会创建另一个合成帧发送到 GPU 用来更新页面。</p><blockquote><p><img src="/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%89%E6%A0%85%E5%8C%96-%E5%90%88%E6%88%90.jpg" alt="光栅化-合成"></p></blockquote><p>合成的好处在于它无需涉及主线程即可完成。合成器进程不需要等待样式计算（Style calculation）或 JavaScript 执行。这就是为什么<a href="https://link.juejin.cn/?target=https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">仅通过合成实现动画</a>是最推荐的方式，能取得最好的性能体验。如果需要重新计算布局（layout）或绘制（paint）则必须涉及到主线程。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>Devtools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chrome</tag>
      
      <tag>Devtools</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
