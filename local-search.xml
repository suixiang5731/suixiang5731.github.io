<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Nodejs面试题</title>
    <link href="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Node基础概念"><a href="#一、Node基础概念" class="headerlink" title="一、Node基础概念"></a>一、Node基础概念</h1><h2 id="1-1-Node是什么"><a href="#1-1-Node是什么" class="headerlink" title="1.1 Node是什么"></a>1.1 Node是什么</h2><p>Node.js 是一个开源与跨平台的 JavaScript 运行时环境。在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能。我们可以理解为：Node.js 就是一个服务器端的、非阻塞式I&#x2F;O的、事件驱动的JavaScript运行环境。</p><p>理解Node，有几个基础的概念：非阻塞异步和事件驱动。</p><ul><li><strong>非阻塞异步：</strong> Nodejs采用了非阻塞型I&#x2F;O机制，在做I&#x2F;O操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作。例如，在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。</li><li><strong>事件驱动：</strong> 事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。比如，读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理。</li></ul><p><img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/743f48a205984beda993e302aaa7cde3.awebp" alt="在这里插入图片描述"></p><h2 id="1-2-Node的应用场景及存在的缺点"><a href="#1-2-Node的应用场景及存在的缺点" class="headerlink" title="1.2 Node的应用场景及存在的缺点"></a>1.2 Node的应用场景及存在的缺点</h2><h3 id="1-2-1-优缺点"><a href="#1-2-1-优缺点" class="headerlink" title="1.2.1 优缺点"></a>1.2.1 优缺点</h3><p>Node.js适合用于I&#x2F;O密集型应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I&#x2F;O硬盘内存读写操作。缺点如下：</p><ul><li>不适合CPU密集型应用</li><li>只支持单核CPU，不能充分利用CPU</li><li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li></ul><p>对于第三点，常用的解决方案是，使用Nnigx反向代理，开多个进程绑定多个端口，或者开多个进程监听同一个端口。</p><h3 id="1-2-1-应用场景"><a href="#1-2-1-应用场景" class="headerlink" title="1.2.1 应用场景"></a>1.2.1 应用场景</h3><p>在熟悉了Nodejs的优点和弊端后，我们可以看到它适合以下的应用场景：</p><ul><li>善于I&#x2F;O，不善于计算。因为Nodejs是一个单线程，如果计算（同步）太多，则会阻塞这个线程。</li><li>大量并发的I&#x2F;O，应用程序内部并不需要进行非常复杂的处理。</li><li>与 WeSocket 配合，开发长连接的实时交互应用程序。</li></ul><p>具体的使用场景如下：</p><ol><li>用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序。</li><li>基于web、canvas等多人联网游戏。</li><li>基于web的多人实时聊天客户端、聊天室、图文直播。</li><li>单页面浏览器应用程序。</li><li>操作数据库、为前端和移动端提供基于json的API。</li></ol><h1 id="二、Node全部对象"><a href="#二、Node全部对象" class="headerlink" title="二、Node全部对象"></a>二、Node全部对象</h1><p>在浏览器 JavaScript 中，window 是全局对象， 而 Nodejs 中的全局对象则是 <strong>global</strong>。</p><p>在NodeJS里，是不可能在最外层定义一个变量，因为所有的用户代码都是当前模块的，只在当前模块里可用，但可以通过exports对象的使用将其传递给模块外部。所以，在NodeJS中，用var声明的变量并不属于全局的变量，只在当前模块生效。像上述的global全局对象则在全局作用域中，任何全局变量、函数、对象都是该对象的一个属性值。</p><h2 id="2-1-常见全局对象"><a href="#2-1-常见全局对象" class="headerlink" title="2.1 常见全局对象"></a>2.1 常见全局对象</h2><p>Node常见的全局对象有如下一些：</p><ul><li>Class:Buffer</li><li>process</li><li>console</li><li>clearInterval、setInterval</li><li>clearTimeout、setTimeout</li><li>global</li></ul><p><strong>Class:Buffer</strong> Class:Buffer可以用来处理二进制以及非Unicode编码的数据，在Buffer类实例化中存储了原始数据。Buffer类似于一个整数数组，在V8堆原始存储空间给它分配了内存，一旦创建了Buffer实例，则无法改变大小。</p><p><strong>process</strong> process表示进程对象，提供有关当前过程的信息和控制。包括在执行node程序的过程中，如果需要传递参数，我们想要获取这个参数需要在process内置对象中。比如，我们有如下一个文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">process.<span class="hljs-property">argv</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val, index</span>) =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;index&#125;</span>: <span class="hljs-subst">$&#123;val&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>当我们需要启动一个进程时，可以使用下面的命令：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">node index.js 参数...<br></code></pre></td></tr></table></figure><p><strong>console</strong> console主要用来打印stdout和stderr，最常用的比如日志输出：<code>console.log</code>。清空控制台的命令为：<code>console.clear</code>。如果需要打印函数的调用栈，可以使用命令<code>console.trace</code>。</p><p><strong>clearInterval、setInterval</strong> setInterval用于设置定时器，语法格式如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">setInterval</span>(callback, delay[, ...args])<br></code></pre></td></tr></table></figure><p>clearInterval则用于清除定时器，callback每delay毫秒重复执行一次。</p><p><strong>clearTimeout、setTimeout</strong></p><p>和setInterval一样，setTimeout主要用于设置延时器，而clearTimeout则用于清除设置的延时器。</p><p><strong>global</strong> global是一个全局命名空间对象，前面讲到的process、console、setTimeout等可以放到global中，例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">console.<span class="hljs-built_in">log</span>(process === global.process)     <span class="hljs-comment">//输出true</span><br></code></pre></td></tr></table></figure><h2 id="2-2-模块中的全局对象"><a href="#2-2-模块中的全局对象" class="headerlink" title="2.2 模块中的全局对象"></a>2.2 模块中的全局对象</h2><p>除了系统提供的全局对象外，还有一些只是在模块中出现，看起来像全局变量，如下所示：</p><ul><li>__dirname</li><li>__filename</li><li>exports</li><li>module</li><li>require</li></ul><p><strong>__dirname</strong> __dirname主要用于获取当前文件所在的路径，不包括后面的文件名。比如，在<code>/Users/mjr</code> 中运行 <code>node example.js</code>，打印结果如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">console.<span class="hljs-built_in">log</span>(__dirname);         <span class="hljs-comment">// 打印: /Users/mjr</span><br></code></pre></td></tr></table></figure><p><strong>__filename</strong> __filename用于获取当前文件所在的路径和文件名称，包括后面的文件名称。比如，在<code>/Users/mjr</code> 中运行 <code>node example.js</code>，打印的结果如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">console.<span class="hljs-built_in">log</span>(__filename);<span class="hljs-comment">// 打印: /Users/mjr/example.js</span><br></code></pre></td></tr></table></figure><p><strong>exports</strong> module.exports 用于导出一个指定模块所的内容，然后也可以使用require() 访问里面的内容。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">exports.name</span> = name<span class="hljs-comment">;exports.age = age;</span><br><span class="hljs-attr">exports.sayHello</span> = sayHello<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>require</strong> require主要用于引入模块、 JSON、或本地文件， 可以从 node_modules 引入模块。可以使用相对路径引入本地模块或JSON文件，路径会根据__dirname定义的目录名或当前工作目录进行处理。</p><h1 id="三、谈谈对process的理解"><a href="#三、谈谈对process的理解" class="headerlink" title="三、谈谈对process的理解"></a>三、谈谈对process的理解</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><p>我们知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器。当我们启动一个js文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享。</p><p>process 对象是Node的一个全局变量，提供了有关当前 Node.js 进程的信息并对其进行控制。 由于JavaScript是一个单线程语言，所以通过node xxx启动一个文件后，只有一条主线程。</p><h2 id="3-2-常用属性和方法"><a href="#3-2-常用属性和方法" class="headerlink" title="3.2 常用属性和方法"></a>3.2 常用属性和方法</h2><p>process的常见属性如下：</p><ul><li>process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息</li><li>process.nextTick：这个在谈及 EventLoop 时经常为会提到</li><li>process.pid：获取当前进程id</li><li>process.ppid：当前进程对应的父进程</li><li>process.cwd()：获取当前进程工作目录</li><li>process.platform：获取当前进程运行的操作系统平台</li><li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值 进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</li><li>三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li><li>process.title：用于指定进程名称，有的时候需要给进程指定一个名称</li></ul><h1 id="四、谈谈你对fs模块的理解"><a href="#四、谈谈你对fs模块的理解" class="headerlink" title="四、谈谈你对fs模块的理解"></a>四、谈谈你对fs模块的理解</h1><h2 id="4-1-fs是什么"><a href="#4-1-fs是什么" class="headerlink" title="4.1 fs是什么"></a>4.1 fs是什么</h2><p>fs（filesystem）是文件系统模块，该模块提供本地文件的读写能力，基本上是POSIX文件操作命令的简单包装。可以说，所有与文件的操作都是通过fs核心模块来实现的。</p><p>使用之前，需要先导入fs模块，如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="4-2-文件基础知识"><a href="#4-2-文件基础知识" class="headerlink" title="4.2 文件基础知识"></a>4.2 文件基础知识</h2><p>在计算机中，有关于文件的基础知识有如下一些：</p><ul><li>权限位 mode</li><li>标识位 flag</li><li>文件描述为 fd</li></ul><h3 id="4-2-1-权限位-mode"><a href="#4-2-1-权限位-mode" class="headerlink" title="4.2.1 权限位 mode"></a>4.2.1 权限位 mode</h3><p><img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/d591b16a39354b4b8789177cc1311663.awebp" alt="在这里插入图片描述"> 针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位4、2、1，不具备权限为0。如在linux查看文件权限位的命令如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">drwxr-xr-x 1 PandaShen 197121 0 Jun 28 14:41 core<br><span class="hljs-deletion">-rw-r--r-- 1 PandaShen 197121 293 Jun 23 17:44 index.md</span><br></code></pre></td></tr></table></figure><p>在开头前十位中，d为文件夹，-为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限。</p><h3 id="4-2-2-标识位"><a href="#4-2-2-标识位" class="headerlink" title="4.2.2 标识位"></a>4.2.2 标识位</h3><p>标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示： <img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/f6b0c62e30dc4a2a9f7997a8d59e717d.awebp" alt="在这里插入图片描述"></p><h3 id="4-2-3-文件描述-fd"><a href="#4-2-3-文件描述-fd" class="headerlink" title="4.2.3 文件描述 fd"></a>4.2.3 文件描述 fd</h3><p>操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件。</p><p>Window 系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，NodeJS 抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符。</p><p>在 NodeJS 中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，因为前面有 0、1、2三个比较特殊的描述符，分别代表 process.stdin（标准输入）、process.stdout（标准输出）和 process.stderr（错误输出）。</p><h2 id="4-3-常用方法"><a href="#4-3-常用方法" class="headerlink" title="4.3 常用方法"></a>4.3 常用方法</h2><p>由于fs模块主要是操作文件的，所以常见的文件操作方法有如下一些：</p><ul><li>文件读取</li><li>文件写入</li><li>文件追加写入</li><li>文件拷贝</li><li>创建目录</li></ul><h3 id="4-3-1-文件读取"><a href="#4-3-1-文件读取" class="headerlink" title="4.3.1 文件读取"></a>4.3.1 文件读取</h3><p>常用的文件读取有readFileSync和readFile两个方法。其中，readFileSync表示同步读取，如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">&quot;fs&quot;</span>)<span class="hljs-comment">;</span><br><br>let <span class="hljs-attr">buf</span> = fs.readFileSync(<span class="hljs-string">&quot;1.txt&quot;</span>)<span class="hljs-comment">;</span><br>let <span class="hljs-attr">data</span> = fs.readFileSync(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>)<span class="hljs-comment">;</span><br><br>console.log(buf)<span class="hljs-comment">; // &lt;Buffer 48 65 6c 6c 6f&gt;</span><br>console.log(data)<span class="hljs-comment">; // Hello</span><br></code></pre></td></tr></table></figure><ul><li>第一个参数为读取文件的路径或文件描述符。</li><li>第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding。</li></ul><p>readFile为异步读取方法， readFile 与 readFileSync 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 err（错误）和 data（数据），该方法没有返回值，回调函数在读取文件成功后执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;1.txt&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>   <span class="hljs-keyword">if</span>(!err)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);         <span class="hljs-comment">// Hello</span><br>   &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-2-文件写入"><a href="#4-3-2-文件写入" class="headerlink" title="4.3.2 文件写入"></a>4.3.2 文件写入</h3><p>文件写入需要用到writeFileSync和writeFile两个方法。writeFileSync表示同步写入，如下所示。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">&quot;fs&quot;</span>)<span class="hljs-comment">;</span><br><br>fs.writeFileSync(&quot;2.txt&quot;, &quot;Hello world&quot;)<span class="hljs-comment">;</span><br>let <span class="hljs-attr">data</span> = fs.readFileSync(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>)<span class="hljs-comment">;</span><br><br>console.log(data)<span class="hljs-comment">; // Hello world</span><br></code></pre></td></tr></table></figure><ul><li>第一个参数为写入文件的路径或文件描述符。</li><li>第二个参数为写入的数据，类型为 String 或 Buffer。</li><li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding。</li></ul><p>writeFile表示异步写入，writeFile 与 writeFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件写入数据成功后执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;Hello world&quot;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!err) &#123;<br>        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;2.txt&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);       <span class="hljs-comment">// Hello world</span><br>        &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-3-文件追加写入"><a href="#4-3-3-文件追加写入" class="headerlink" title="4.3.3 文件追加写入"></a>4.3.3 文件追加写入</h3><p>文件追加写入需要用到appendFileSync和appendFile两个方法。appendFileSync表示同步写入，如下。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">&quot;fs&quot;</span>)<span class="hljs-comment">;</span><br><br>fs.appendFileSync(&quot;3.txt&quot;, &quot; world&quot;)<span class="hljs-comment">;</span><br>let <span class="hljs-attr">data</span> = fs.readFileSync(<span class="hljs-string">&quot;3.txt&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>第一个参数为写入文件的路径或文件描述符。</li><li>第二个参数为写入的数据，类型为 String 或 Buffer。</li><li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding。</li></ul><p>appendFile表示异步追加写入，方法 appendFile 与 appendFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件追加写入数据成功后执行，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><br>fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">&quot;3.txt&quot;</span>, <span class="hljs-string">&quot; world&quot;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!err) &#123;<br>        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;3.txt&quot;</span>, <span class="hljs-string">&quot;utf8&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// Hello world</span><br>        &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-4-创建目录"><a href="#4-3-4-创建目录" class="headerlink" title="4.3.4 创建目录"></a>4.3.4 创建目录</h3><p>创建目录主要有mkdirSync和mkdir两个方法。其中，mkdirSync为同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">// 假设已经有了 <span class="hljs-selector-tag">a</span> 文件夹和 <span class="hljs-selector-tag">a</span> 下的 <span class="hljs-selector-tag">b</span> 文件夹<br>fs<span class="hljs-selector-class">.mkdirSync</span>(&quot;<span class="hljs-selector-tag">a</span>/<span class="hljs-selector-tag">b</span>/c&quot;)<br></code></pre></td></tr></table></figure><p>mkdir为异步创建，第二个参数为回调函数，如下所示。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">fs.mkdir(&quot;a/b/c&quot;, <span class="hljs-attr">err</span> =&gt; &#123;<br>    if (!err) console.log(&quot;创建成功&quot;)<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="五、谈谈你对Stream-的理解"><a href="#五、谈谈你对Stream-的理解" class="headerlink" title="五、谈谈你对Stream 的理解"></a>五、谈谈你对Stream 的理解</h1><h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><p>流（Stream）是一种数据传输的手段，是一种端到端信息交换的方式，而且是有顺序的，是逐块读取数据、处理内容，用于顺序读取输入或写入输出。在Node中，Stream分成三部分：source、dest、pipe。</p><p>其中，在source和dest之间有一个连接的管道pipe，它的基本语法是source.pipe(dest)，source和dest就是通过pipe连接，让数据从source流向dest，如下图所示： <img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/20b2685b0c244da2a242d03c9e825364.awebp" alt="在这里插入图片描述"></p><h2 id="5-2-流的分类"><a href="#5-2-流的分类" class="headerlink" title="5.2 流的分类"></a>5.2 流的分类</h2><p>在Node，流可以分成四个种类：</p><ul><li><strong>可写流</strong>：可写入数据的流，例如 fs.createWriteStream() 可以使用流将数据写入文件。</li><li><strong>可读流</strong>： 可读取数据的流，例如fs.createReadStream() 可以从文件读取内容。</li><li><strong>双工流</strong>： 既可读又可写的流，例如 net.Socket。</li><li><strong>转换流</strong>： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据。</li></ul><p>在Node的HTTP服务器模块中，request 是可读流，response 是可写流。对于fs 模块来说，能同时处理可读和可写文件流可读流和可写流都是单向的，比较容易理解。而Socket是双向的，可读可写。</p><h3 id="5-2-1-双工流"><a href="#5-2-1-双工流" class="headerlink" title="5.2.1 双工流"></a>5.2.1 双工流</h3><p>在Node中，比较的常见的全双工通信就是websocket，因为发送方和接受方都是各自独立的方法，发送和接收都没有任何关系。 <img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/312c0d3eb5284ce4a301421edcf1ad56.awebp" alt="在这里插入图片描述"> 基本的使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Duplex</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;stream&#x27;</span>);<br><br><span class="hljs-keyword">const</span> myDuplex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Duplex</span>(&#123;<br>  <span class="hljs-title function_">read</span>(<span class="hljs-params">size</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;,<br>  <span class="hljs-title function_">write</span>(<span class="hljs-params">chunk, encoding, callback</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="5-3-使用场景"><a href="#5-3-使用场景" class="headerlink" title="5.3 使用场景"></a>5.3 使用场景</h2><p>流的常见使用场景有：</p><ul><li>get请求返回文件给客户端</li><li>文件操作</li><li>一些打包工具的底层操作</li></ul><h3 id="5-3-1-网络请求"><a href="#5-3-1-网络请求" class="headerlink" title="5.3.1 网络请求"></a>5.3.1 网络请求</h3><p>流一个常见的使用场景就是网络请求，比如使用stream流返回文件，res也是一个stream对象，通过pipe管道将文件数据返回。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">server</span> = http.createServer(function (req, res) &#123;<br>    const <span class="hljs-attr">method</span> = req.method<span class="hljs-comment">;  </span><br>    // get 请求<br>    if (<span class="hljs-attr">method</span> === <span class="hljs-string">&#x27;GET&#x27;</span>) &#123; <br>        const <span class="hljs-attr">fileName</span> = path.resolve(__dirname, <span class="hljs-string">&#x27;data.txt&#x27;</span>)<span class="hljs-comment">;</span><br>        let <span class="hljs-attr">stream</span> = fs.createReadStream(fileName)<span class="hljs-comment">;</span><br>        stream.pipe(res)<span class="hljs-comment">;   </span><br>    &#125;<br>&#125;)<span class="hljs-comment">;</span><br>server.listen(8080)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="5-3-2-文件操作"><a href="#5-3-2-文件操作" class="headerlink" title="5.3.2 文件操作"></a>5.3.2 文件操作</h3><p>文件的读取也是流操作，创建一个可读数据流readStream，一个可写数据流writeStream，通过pipe管道把数据流转过去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-comment">// 两个文件名</span><br><span class="hljs-keyword">const</span> fileName1 = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;data.txt&#x27;</span>)<br><span class="hljs-keyword">const</span> fileName2 = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;data-bak.txt&#x27;</span>)<br><span class="hljs-comment">// 读取文件的 stream 对象</span><br><span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(fileName1)<br><span class="hljs-comment">// 写入文件的 stream 对象</span><br><span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(fileName2)<br><span class="hljs-comment">// 通过 pipe执行拷贝，数据流转</span><br>readStream.<span class="hljs-title function_">pipe</span>(writeStream)<br><span class="hljs-comment">// 数据读取完成监听，即拷贝完成</span><br>readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;拷贝完成&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>另外，一些打包工具，Webpack和Vite等都涉及很多流的操作。</p><h1 id="六、事件循环机制"><a href="#六、事件循环机制" class="headerlink" title="六、事件循环机制"></a>六、事件循环机制</h1><h2 id="6-1-什么是浏览器事件循环"><a href="#6-1-什么是浏览器事件循环" class="headerlink" title="6.1 什么是浏览器事件循环"></a>6.1 什么是浏览器事件循环</h2><p>Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I&#x2F;O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I&#x2F;O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</p><p>当线程中的 I&#x2F;O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)，其运行原理如下图所示。</p><p><img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/d41cb74e85354e58858c71a6af8f79c8.awebp" alt="在这里插入图片描述"> 从左到右，从上到下，Node.js 被分为了四层，分别是 应用层、V8引擎层、Node API层 和 LIBUV层。</p><ul><li><strong>应用层</strong>： 即 JavaScript 交互层，常见的就是 Node.js 的模块，比如 http，fs</li><li><strong>V8引擎层</strong>： 即利用 V8 引擎来解析JavaScript 语法，进而和下层 API 交互</li><li><strong>Node API层</strong>： 为上层模块提供系统调用，一般是由 C 语言来实现，和操作系统进行交互 。</li><li><strong>LIBUV层</strong>： 是跨平台的底层封装，实现了 事件循环、文件操作等，是 Node.js 实现异步的核心 。</li></ul><p>在Node中，我们所说的事件循环是基于libuv实现的，libuv是一个多平台的专注于异步IO的库。上图的EVENT_QUEUE 给人看起来只有一个队列，但事实上EventLoop存在6个阶段，每个阶段都有对应的一个先进先出的回调队列。</p><h2 id="6-2-事件循环的六个阶段"><a href="#6-2-事件循环的六个阶段" class="headerlink" title="6.2 事件循环的六个阶段"></a>6.2 事件循环的六个阶段</h2><p>事件循环一共可以分成了六个阶段，如下图所示。 <img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/9dea7d0107f446fb8b75f56bbe60d9ce.awebp" alt="在这里插入图片描述"></p><ul><li>timers阶段：此阶段主要执行timer（setTimeout、setInterval）的回调。</li><li>I&#x2F;O事件回调阶段(I&#x2F;O callbacks)：执行延迟到下一个循环迭代的 I&#x2F;O 回调，即上一轮循环中未被执行的一些I&#x2F;O回调。</li><li>闲置阶段(idle、prepare)：仅系统内部使用。</li><li>轮询阶段(poll)：检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li><li>检查阶段(check)：setImmediate() 回调函数在这里执行</li><li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)</li></ul><p>每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段，如下图所示。 <img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/c641dbe328574fc5ad3d2c3ab47f0338.awebp" alt="在这里插入图片描述"></p><h1 id="七、EventEmitter"><a href="#七、EventEmitter" class="headerlink" title="七、EventEmitter"></a>七、EventEmitter</h1><h2 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h2><p>前文说过，Node采用了事件驱动机制，而EventEmitter 就是Node实现事件驱动的基础。在EventEmitter的基础上，Node 几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定、触发监听器，实现了异步操作。</p><p>Node.js 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件，这些产生事件的对象都是 events.EventEmitter 的实例，用于将一个或多个函数绑定到命名事件上。</p><h2 id="7-2-基本使用"><a href="#7-2-基本使用" class="headerlink" title="7.2 基本使用"></a>7.2 基本使用</h2><p>Node的events模块只提供了一个EventEmitter类，这个类实现了Node异步事件驱动架构的基本模式：观察者模式。</p><p>在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新会依次通知观察者，使用方式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEmitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> &#123;&#125;<br><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>()<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;触发了event事件！&#x27;</span>)<br>&#125;<br>myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;event&#x27;</span>, callback)<br>myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;event&#x27;</span>)<br>myEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">&#x27;event&#x27;</span>, callback);<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们通过实例对象的on方法注册一个名为event的事件，通过emit方法触发该事件，而removeListener用于取消事件的监听。</p><p>除了上面介绍的一些方法外，其他常用的方法还有如下一些：</p><ul><li><strong>emitter.addListener&#x2F;on(eventName, listener)</strong> ：添加类型为 eventName 的监听事件到事件数组尾部。</li><li>**emitter.prependListener(eventName, listener)**：添加类型为 eventName 的监听事件到事件数组头部。</li><li>**emitter.emit(eventName[, …args])**：触发类型为 eventName 的监听事件。</li><li>**emitter.removeListener&#x2F;off(eventName, listener)**：移除类型为 eventName 的监听事件。</li><li>**emitter.once(eventName, listener)**：添加类型为 eventName 的监听事件，以后只能执行一次并删除。</li><li>**emitter.removeAllListeners([eventName])**： 移除全部类型为 eventName 的监听事件。</li></ul><h2 id="7-3-实现原理"><a href="#7-3-实现原理" class="headerlink" title="7.3 实现原理"></a>7.3 实现原理</h2><p>EventEmitter其实是一个构造函数，内部存在一个包含所有事件的对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>    <span class="hljs-keyword">constructor</span>() &#123;<br>        <span class="hljs-keyword">this</span>.events = &#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，events存放的监听事件的函数的结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;event1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>f1<span class="hljs-punctuation">,</span>f2<span class="hljs-punctuation">,</span>f3<span class="hljs-punctuation">]</span>，<br>  <span class="hljs-attr">&quot;event2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>f4<span class="hljs-punctuation">,</span>f5<span class="hljs-punctuation">]</span>，<br>  ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后，开始一步步实现实例方法，首先是emit，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">emit</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, ...args</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(item, <span class="hljs-variable language_">this</span>, args);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>实现了emit方法之后，然后依次实现on、addListener、prependListener这三个实例方法，它们都是添加事件监听触发函数的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">on</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[<span class="hljs-keyword">type</span>]) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[<span class="hljs-keyword">type</span>] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">push</span>(handler);<br>&#125;<br><br><span class="hljs-title function_">addListener</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>,handler</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(<span class="hljs-keyword">type</span>,handler)<br>&#125;<br><br><span class="hljs-title function_">prependListener</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[<span class="hljs-keyword">type</span>]) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[<span class="hljs-keyword">type</span>] = [];<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">unshift</span>(handler);<br>&#125;<br></code></pre></td></tr></table></figure><p>移除事件监听，可以使用方法removeListener&#x2F;on。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">removeListener</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[<span class="hljs-keyword">type</span>]) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[<span class="hljs-keyword">type</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item !== handler);<br>&#125;<br><br><span class="hljs-title function_">off</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>,handler</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeListener</span>(<span class="hljs-keyword">type</span>,handler)<br>&#125;<br></code></pre></td></tr></table></figure><p>实现once方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过fired属性值判断事件函数是否执行过。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">once(type, handler) &#123;<br>    <span class="hljs-keyword">this</span>.on(type, <span class="hljs-keyword">this</span>._onceWrap(type, handler, <span class="hljs-keyword">this</span>));<br>  &#125;<br><br>  _onceWrap(type, handler, target) &#123;<br>    <span class="hljs-keyword">const</span> state = &#123; fired: <span class="hljs-literal">false</span>, handler, type , target&#125;;<br>    <span class="hljs-keyword">const</span> wrapFn = <span class="hljs-keyword">this</span>._onceWrapper.bind(state);<br>    state.wrapFn = wrapFn;<br>    <span class="hljs-keyword">return</span> wrapFn;<br>  &#125;<br><br>  _onceWrapper(...args) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.fired) &#123;<br>      <span class="hljs-keyword">this</span>.fired = <span class="hljs-literal">true</span>;<br>      Reflect.apply(<span class="hljs-keyword">this</span>.handler, <span class="hljs-keyword">this</span>.target, args);<br>      <span class="hljs-keyword">this</span>.target.off(<span class="hljs-keyword">this</span>.type, <span class="hljs-keyword">this</span>.wrapFn);<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>下面是完成的测试代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>    <span class="hljs-keyword">constructor</span>() &#123;<br>        <span class="hljs-keyword">this</span>.events = &#123;&#125;;<br>    &#125;<br><br>    on(type, handler) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[type]) &#123;<br>            <span class="hljs-keyword">this</span>.events[type] = [];<br>        &#125;<br>        <span class="hljs-keyword">this</span>.events[type].push(handler);<br>    &#125;<br><br>    addListener(type,handler)&#123;<br>        <span class="hljs-keyword">this</span>.on(type,handler)<br>    &#125;<br><br>    prependListener(type, handler) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[type]) &#123;<br>            <span class="hljs-keyword">this</span>.events[type] = [];<br>        &#125;<br>        <span class="hljs-keyword">this</span>.events[type].unshift(handler);<br>    &#125;<br><br>    removeListener(type, handler) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[type]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.events[type] = <span class="hljs-keyword">this</span>.events[type].filter(item =&gt; item !== handler);<br>    &#125;<br><br>    off(type,handler)&#123;<br>        <span class="hljs-keyword">this</span>.removeListener(type,handler)<br>    &#125;<br><br>    emit(type, ...args) &#123;<br>        <span class="hljs-keyword">this</span>.events[type].forEach((item) =&gt; &#123;<br>            Reflect.apply(item, <span class="hljs-keyword">this</span>, args);<br>        &#125;);<br>    &#125;<br><br>    once(type, handler) &#123;<br>        <span class="hljs-keyword">this</span>.on(type, <span class="hljs-keyword">this</span>._onceWrap(type, handler, <span class="hljs-keyword">this</span>));<br>    &#125;<br><br>    _onceWrap(type, handler, target) &#123;<br>        <span class="hljs-keyword">const</span> state = &#123; fired: <span class="hljs-literal">false</span>, handler, type , target&#125;;<br>        <span class="hljs-keyword">const</span> wrapFn = <span class="hljs-keyword">this</span>._onceWrapper.bind(state);<br>        state.wrapFn = wrapFn;<br>        <span class="hljs-keyword">return</span> wrapFn;<br>    &#125;<br><br>    _onceWrapper(...args) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.fired) &#123;<br>            <span class="hljs-keyword">this</span>.fired = <span class="hljs-literal">true</span>;<br>            Reflect.apply(<span class="hljs-keyword">this</span>.handler, <span class="hljs-keyword">this</span>.target, args);<br>            <span class="hljs-keyword">this</span>.target.off(<span class="hljs-keyword">this</span>.type, <span class="hljs-keyword">this</span>.wrapFn);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="八、中间件"><a href="#八、中间件" class="headerlink" title="八、中间件"></a>八、中间件</h1><h2 id="8-1-基本概念"><a href="#8-1-基本概念" class="headerlink" title="8.1 基本概念"></a>8.1 基本概念</h2><p>中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。 在Node中，中间件主要是指封装http请求细节处理的方法。例如，在express、koa等web框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数，架构示意图如下。</p><p><img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/3dbf905e577d44d0844a6f4799b32d4c.webp" alt="在这里插入图片描述"></p><p>通常，在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作。</p><h2 id="8-2-koa"><a href="#8-2-koa" class="headerlink" title="8.2 koa"></a>8.2 koa</h2><p>Koa是基于Node当前比较流行的web框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助开发者快速而愉快地编写服务端应用程序。 <img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/9825eb67536a4a2993792e3af28fad56.awebp" alt="在这里插入图片描述"></p><p>Koa 中间件采用的是洋葱圈模型，每次执行下一个中间件都传入两个参数：</p><ul><li>ctx ：封装了request 和 response 的变量</li><li>next ：进入下一个要执行的中间件的函数</li></ul><p>通过前面的介绍，我们知道了Koa 中间件本质上就是一个函数，可以是 async 函数，也可以是普通函数。下面就针对koa进行中间件的封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// async 函数</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>  <span class="hljs-keyword">const</span> ms = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;ctx.method&#125;</span> <span class="hljs-subst">$&#123;ctx.url&#125;</span> - <span class="hljs-subst">$&#123;ms&#125;</span>ms`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 普通函数</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">ctx, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> ms = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;ctx.method&#125;</span> <span class="hljs-subst">$&#123;ctx.url&#125;</span> - <span class="hljs-subst">$&#123;ms&#125;</span>ms`</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>当然，我们还可以通过中间件封装http请求过程中几个常用的功能：</p><p><strong>token校验</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">options</span>) =&gt;</span> <span class="hljs-keyword">async</span> (ctx, next) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取 token</span><br>    <span class="hljs-keyword">const</span> token = ctx.<span class="hljs-property">header</span>.<span class="hljs-property">authorization</span><br>    <span class="hljs-keyword">if</span> (token) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// verify 函数验证 token，并获取用户相关信息</span><br>          <span class="hljs-keyword">await</span> <span class="hljs-title function_">verify</span>(token)<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 进入下一个中间件</span><br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>日志模块</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">options</span>) =&gt;</span> <span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>  <span class="hljs-keyword">const</span> requestTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()<br>  <span class="hljs-keyword">const</span> ms = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - startTime;<br>  <span class="hljs-keyword">let</span> logout = <span class="hljs-string">`<span class="hljs-subst">$&#123;ctx.request.ip&#125;</span> -- <span class="hljs-subst">$&#123;requestTime&#125;</span> -- <span class="hljs-subst">$&#123;ctx.method&#125;</span> -- <span class="hljs-subst">$&#123;ctx.url&#125;</span> -- <span class="hljs-subst">$&#123;ms&#125;</span>ms`</span>;<br>  <span class="hljs-comment">// 输出日志文件</span><br>  fs.<span class="hljs-title function_">appendFileSync</span>(<span class="hljs-string">&#x27;./log.txt&#x27;</span>, logout + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>Koa存在很多第三方的中间件，如koa-bodyparser、koa-static等。</p><h2 id="8-3-Koa中间件"><a href="#8-3-Koa中间件" class="headerlink" title="8.3 Koa中间件"></a>8.3 Koa中间件</h2><p><strong>koa-bodyparser</strong> koa-bodyparser 中间件是将我们的 post 请求和表单提交的查询字符串转换成对象，并挂在 ctx.request.body 上，方便我们在其他中间件或接口处取值。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 文件：my-koa-bodyparser.js<br>const <span class="hljs-attr">querystring</span> = require(<span class="hljs-string">&quot;querystring&quot;</span>)<span class="hljs-comment">;</span><br><br><span class="hljs-attr">module.exports</span> = function bodyParser() &#123;<br>    return async (ctx, next) =&gt; &#123;<br>        await new Promise((resolve, reject) =&gt; &#123;<br>            // 存储数据的数组<br>            let <span class="hljs-attr">dataArr</span> = []<span class="hljs-comment">;</span><br><br>            // 接收数据<br>            ctx.req.on(&quot;data&quot;, <span class="hljs-attr">data</span> =&gt; dataArr.push(data))<span class="hljs-comment">;</span><br><br>            // 整合数据并使用 Promise 成功<br>            ctx.req.on(&quot;end&quot;, () =&gt; &#123;<br>                // 获取请求数据的类型 json 或表单<br>                let <span class="hljs-attr">contentType</span> = ctx.get(<span class="hljs-string">&quot;Content-Type&quot;</span>)<span class="hljs-comment">;</span><br><br>                // 获取数据 Buffer 格式<br>                let <span class="hljs-attr">data</span> = Buffer.concat(dataArr).toString()<span class="hljs-comment">;</span><br><br>                if (<span class="hljs-attr">contentType</span> === <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>) &#123;<br>                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body<br>                    <span class="hljs-attr">ctx.request.body</span> = querystring.parse(data)<span class="hljs-comment">;</span><br>                &#125; else if (<span class="hljs-attr">contentType</span> === <span class="hljs-string">&quot;applaction/json&quot;</span>) &#123;<br>                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body<br>                    <span class="hljs-attr">ctx.request.body</span> = JSON.parse(data)<span class="hljs-comment">;</span><br>                &#125;<br><br>                // 执行成功的回调<br>                resolve()<span class="hljs-comment">;</span><br>            &#125;)<span class="hljs-comment">;</span><br>        &#125;)<span class="hljs-comment">;</span><br><br>        // 继续向下执行<br>        await next()<span class="hljs-comment">;</span><br>    &#125;<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>koa-static</strong> koa-static 中间件的作用是在服务器接到请求时，帮我们处理静态文件，比如。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">&quot;fs&quot;</span>)<span class="hljs-comment">;</span><br>const <span class="hljs-attr">path</span> = require(<span class="hljs-string">&quot;path&quot;</span>)<span class="hljs-comment">;</span><br>const <span class="hljs-attr">mime</span> = require(<span class="hljs-string">&quot;mime&quot;</span>)<span class="hljs-comment">;</span><br>const &#123; promisify &#125; = require(&quot;util&quot;)<span class="hljs-comment">;</span><br><br>// 将 stat 和 access 转换成 Promise<br>const <span class="hljs-attr">stat</span> = promisify(fs.stat)<span class="hljs-comment">;</span><br>const <span class="hljs-attr">access</span> = promisify(fs.access)<br><br><span class="hljs-attr">module.exports</span> = function (dir) &#123;<br>    return async (ctx, next) =&gt; &#123;<br>        // 将访问的路由处理成绝对路径，这里要使用 join 因为有可能是 /<br>        let <span class="hljs-attr">realPath</span> = path.join(dir, ctx.path)<span class="hljs-comment">;</span><br><br>        try &#123;<br>            // 获取 stat 对象<br>            let <span class="hljs-attr">statObj</span> = await stat(realPath)<span class="hljs-comment">;</span><br><br>            // 如果是文件，则设置文件类型并直接响应内容，否则当作文件夹寻找 index.html<br>            if (statObj.isFile()) &#123;<br>                ctx.set(&quot;Content-Type&quot;, `$&#123;mime.getType()&#125;<span class="hljs-comment">;charset=utf8`);</span><br>                <span class="hljs-attr">ctx.body</span> = fs.createReadStream(realPath)<span class="hljs-comment">;</span><br>            &#125; else &#123;<br>                let <span class="hljs-attr">filename</span> = path.join(realPath, <span class="hljs-string">&quot;index.html&quot;</span>)<span class="hljs-comment">;</span><br><br>                // 如果不存在该文件则执行 catch 中的 next 交给其他中间件处理<br>                await access(filename)<span class="hljs-comment">;</span><br><br>                // 存在设置文件类型并响应内容<br>                ctx.set(&quot;Content-Type&quot;, &quot;text/html<span class="hljs-comment">;charset=utf8&quot;);</span><br>                <span class="hljs-attr">ctx.body</span> = fs.createReadStream(filename)<span class="hljs-comment">;</span><br>            &#125;<br>        &#125; catch (e) &#123;<br>            await next()<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据。</p><h1 id="九、如何设计并实现JWT鉴权"><a href="#九、如何设计并实现JWT鉴权" class="headerlink" title="九、如何设计并实现JWT鉴权"></a>九、如何设计并实现JWT鉴权</h1><h2 id="9-1-JWT是什么"><a href="#9-1-JWT是什么" class="headerlink" title="9.1 JWT是什么"></a>9.1 JWT是什么</h2><p>JWT（JSON Web Token），本质就是一个字符串书写规范，作用是用来在用户和服务器之间传递安全可靠的，如下图。 <img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/ac7e2083e4aa41f09069e960599ed500.awebp" alt="在这里插入图片描述"> 在目前前后端分离的开发过程中，使用token鉴权机制用于身份验证是最常见的方案，流程如下：</p><ul><li>服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证。</li><li>后续访问会根据这个令牌判断用户时候有权限进行访问。</li></ul><p>Token，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以<code>.</code>进行拼接。其中头部和载荷都是以JSON格式存放数据，只是进行了编码，示意图如下。 <img src="/2024/04/24/Nodejs%E9%9D%A2%E8%AF%95%E9%A2%98/4f156720e4234cc4ae92e8c396c3ed7btplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="在这里插入图片描述"></p><h3 id="9-1-1-header"><a href="#9-1-1-header" class="headerlink" title="9.1.1 header"></a>9.1.1 header</h3><p>每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为alg，同时还有一个typ的字段，默认JWT即可。以下示例中算法为HS256：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span> <span class="hljs-punctuation">&#125;</span> <br></code></pre></td></tr></table></figure><p>因为JWT是字符串，所以我们还需要对以上内容进行Base64编码，编码后字符串如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9        <br></code></pre></td></tr></table></figure><h3 id="9-1-2-payload"><a href="#9-1-2-payload" class="headerlink" title="9.1.2 payload"></a>9.1.2 payload</h3><p>载荷即消息体，这里会存放实际的内容，也就是Token的数据声明，例如用户的id和name，默认情况下也会携带令牌的签发时间iat，通过还可以设置过期时间，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;iat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1516239022</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>同样进行Base64编码后，字符串如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ<br></code></pre></td></tr></table></figure><h3 id="9-1-3-Signature"><a href="#9-1-3-Signature" class="headerlink" title="9.1.3 Signature"></a>9.1.3 Signature</h3><p>签名是对头部和载荷内容进行签名，一般情况，设置一个secretKey，对前两个的结果进行HMACSHA25算法，公式如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">Signature = <span class="hljs-built_in">HMACSHA256</span>(base64Url(header)+.+<span class="hljs-built_in">base64Url</span>(payload),secretKey)<br></code></pre></td></tr></table></figure><p>因此，就算前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名也是不一致的。</p><h2 id="9-2-设计实现"><a href="#9-2-设计实现" class="headerlink" title="9.2 设计实现"></a>9.2 设计实现</h2><p>通常，Token的使用分成了两部分：生成token和校验token。</p><ul><li><strong>生成token</strong>：登录成功的时候，颁发token。</li><li><strong>验证token</strong>：访问某些资源或者接口时，验证token。</li></ul><h3 id="9-2-1-生成-token"><a href="#9-2-1-生成-token" class="headerlink" title="9.2.1 生成 token"></a>9.2.1 生成 token</h3><p>借助第三方库jsonwebtoken，通过jsonwebtoken 的 sign 方法生成一个 token。sign有三个参数：</p><ul><li>第一个参数指的是 Payload。</li><li>第二个是秘钥，服务端特有。</li><li>第三个参数是 option，可以定义 token 过期时间。</li></ul><p>下面是一个前端生成token的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> crypto = require(<span class="hljs-string">&quot;crypto&quot;</span>),<br>  jwt = require(<span class="hljs-string">&quot;jsonwebtoken&quot;</span>);<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>使用数据库</span><br><span class="hljs-comment">// 这里应该是用数据库存储，这里只是演示用</span><br>let userList = [];<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>  <span class="hljs-comment">// 用户登录</span><br>  static async login(ctx) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">data</span> = ctx.request.body;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">data</span>.name || !<span class="hljs-keyword">data</span>.password) &#123;<br>      <span class="hljs-keyword">return</span> ctx.body = &#123;<br>        code: <span class="hljs-string">&quot;000002&quot;</span>, <br>        message: <span class="hljs-string">&quot;参数不合法&quot;</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> result = userList.find(item =&gt; item.name === <span class="hljs-keyword">data</span>.name &amp;&amp; item.password === crypto.createHash(<span class="hljs-string">&#x27;md5&#x27;</span>).update(<span class="hljs-keyword">data</span>.password).digest(<span class="hljs-string">&#x27;hex&#x27;</span>))<br>    <span class="hljs-keyword">if</span> (result) &#123;<br>      <span class="hljs-comment">// 生成token</span><br>      <span class="hljs-keyword">const</span> token = jwt.sign(  <br>        &#123;<br>          name: result.name<br>        &#125;,<br>        <span class="hljs-string">&quot;test_token&quot;</span>, <span class="hljs-comment">// secret</span><br>        &#123; expiresIn: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> &#125; <span class="hljs-comment">// 过期时间：60 * 60 s</span><br>      );<br>      <span class="hljs-keyword">return</span> ctx.body = &#123;<br>        code: <span class="hljs-string">&quot;0&quot;</span>,<br>        message: <span class="hljs-string">&quot;登录成功&quot;</span>,<br>        <span class="hljs-keyword">data</span>: &#123;<br>          token<br>        &#125;<br>      &#125;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> ctx.body = &#123;<br>        code: <span class="hljs-string">&quot;000002&quot;</span>,<br>        message: <span class="hljs-string">&quot;用户名或密码错误&quot;</span><br>      &#125;;<br>    &#125;<br>  &#125;<br>&#125;<br><br>module.exports = UserController;<br></code></pre></td></tr></table></figure><p>在前端接收到token后，一般情况会通过localStorage进行缓存，然后将token放到HTTP 请求头Authorization 中，关于Authorization 的设置，前面需要加上 Bearer ，注意后面带有空格，如下。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">axios.interceptors.request.<span class="hljs-built_in">use</span>(config =&gt; &#123;<br>  <span class="hljs-type">const</span> token = localStorage.<span class="hljs-built_in">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>);<br>  config.headers.common[<span class="hljs-string">&#x27;Authorization&#x27;</span>] = <span class="hljs-string">&#x27;Bearer &#x27;</span> + token; <span class="hljs-comment">// 留意这里的 Authorization</span><br>  <span class="hljs-keyword">return</span> config;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="9-2-2-校验token"><a href="#9-2-2-校验token" class="headerlink" title="9.2.2 校验token"></a>9.2.2 校验token</h3><p>首先，我们需要使用 koa-jwt 中间件进行验证，方式比较简单，在路由跳转前校验即可，如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">koajwt</span>(&#123;<br>  <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;test_token&#x27;</span><br>&#125;).<span class="hljs-title function_">unless</span>(&#123; <br>   <span class="hljs-comment">// 配置白名单</span><br>  <span class="hljs-attr">path</span>: [<span class="hljs-regexp">/\/api\/register/</span>, <span class="hljs-regexp">/\/api\/login/</span>]<br>&#125;))<br></code></pre></td></tr></table></figure><p>使用koa-jwt中间件进行校验时，需要注意以下几点：</p><ul><li>secret 必须和 sign 时候保持一致。</li><li>可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆&#x2F;注册都可以不用校验。</li><li>校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验。</li></ul><p>获取用户token信息的方法如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini">router.get(&#x27;/api/userInfo&#x27;,async (ctx,next) =&gt;&#123;   <br> const <span class="hljs-attr">authorization</span> =  ctx.header.authorization // 获取jwt  <br> const <span class="hljs-attr">token</span> = authorization.replace(<span class="hljs-string">&#x27;Beraer &#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)    <br> const <span class="hljs-attr">result</span> = jwt.verify(token,<span class="hljs-string">&#x27;test_token&#x27;</span>)  <br> <span class="hljs-attr">ctx.body</span> = result<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上述的HMA256加密算法为单秘钥的形式，一旦泄露后果非常的危险。</p><p>在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌。这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择RS256等非对称算法。</p><p>除此之外，JWT鉴权还需要注意以下几点：</p><ul><li>payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息。</li><li>需要保护好加密密钥，一旦泄露后果不堪设想。</li><li>为避免token被劫持，最好使用https协议。</li></ul><h1 id="十、Node性能监控与优化"><a href="#十、Node性能监控与优化" class="headerlink" title="十、Node性能监控与优化"></a>十、Node性能监控与优化</h1><h2 id="10-1-Node优化点"><a href="#10-1-Node优化点" class="headerlink" title="10.1 Node优化点"></a>10.1 Node优化点</h2><p>Node作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下几点：</p><ul><li>CPU</li><li>内存</li><li>I&#x2F;O</li><li>网络</li></ul><h3 id="10-1-1-CPU"><a href="#10-1-1-CPU" class="headerlink" title="10.1.1 CPU"></a>10.1.1 CPU</h3><p>对于CPU的指标，主要关注如下两点：</p><ul><li><strong>CPU负载</strong>：在某个时间段内，占用以及等待CPU的进程总数。</li><li><strong>CPU使用率</strong>：CPU时间占用状况，等于 1 - 空闲CPU时间(idle time) &#x2F; CPU总时间。</li></ul><p>这两个指标都是用来评估系统当前CPU的繁忙程度的量化指标。Node应用一般不会消耗很多的CPU，如果CPU占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞。</p><h3 id="10-1-2-内存指标"><a href="#10-1-2-内存指标" class="headerlink" title="10.1.2 内存指标"></a>10.1.2 内存指标</h3><p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于Node来说，内部内存堆栈的使用状态也是一个可以量化的指标，可以使用下面的代码来获取内存的相关数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// /app/lib/memory.js</span><br><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<br><span class="hljs-comment">// 获取当前Node内存堆栈情况</span><br><span class="hljs-keyword">const</span> &#123; rss, heapUsed, heapTotal &#125; = process.<span class="hljs-title function_">memoryUsage</span>();<br><span class="hljs-comment">// 获取系统空闲内存</span><br><span class="hljs-keyword">const</span> sysFree = os.<span class="hljs-title function_">freemem</span>();<br><span class="hljs-comment">// 获取系统总内存</span><br><span class="hljs-keyword">const</span> sysTotal = os.<span class="hljs-title function_">totalmem</span>();<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">memory</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">sys</span>: <span class="hljs-number">1</span> - sysFree / sysTotal,  <span class="hljs-comment">// 系统内存占用率</span><br>      <span class="hljs-attr">heap</span>: heapUsed / headTotal,   <span class="hljs-comment">// Node堆内存占用率</span><br>      <span class="hljs-attr">node</span>: rss / sysTotal,         <span class="hljs-comment">// Node占用系统内存的比例</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>rss：表示node进程占用的内存总量。</li><li>heapTotal：表示堆内存的总量。</li><li>heapUsed：实际堆内存的使用量。</li><li>external ：外部程序的内存使用量，包含Node核心的C++程序的内存使用量。</li></ul><p>在Node中，一个进程的最大内存容量为1.5GB，因此在实际使用时请合理控制内存的使用。</p><h3 id="10-13-磁盘-I-x2F-O"><a href="#10-13-磁盘-I-x2F-O" class="headerlink" title="10.13 磁盘 I&#x2F;O"></a>10.13 磁盘 I&#x2F;O</h3><p>硬盘的 IO 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍。内存 IO 比磁盘 IO 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 redis、memcached 等。</p><p>并且，并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决。</p><h2 id="10-2-如何监控"><a href="#10-2-如何监控" class="headerlink" title="10.2 如何监控"></a>10.2 如何监控</h2><p>关于性能方面的监控，一般情况都需要借助工具来实现，比如Easy-Monitor、阿里Node性能平台等。</p><p>这里采用Easy-Monitor 2.0，其是轻量级的 Node.js 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 require 一次，无需改动任何业务代码即可开启内核级别的性能监控分析。</p><p>Easy-Monitor 的使用也比较简单，在项目入口文件中按照如下方式引入。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">easyMonitor</span> = require(<span class="hljs-string">&#x27;easy-monitor&#x27;</span>)<span class="hljs-comment">;</span><br>easyMonitor(&#x27;项目名称&#x27;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>打开你的浏览器，访问 <a href="http://localhost:12333/" title="http://localhost:12333">http://localhost:12333</a> ，即可看到进程界面，更详细的内容请参考<a href="https://www.npmjs.com/package/easy-monitor" title="https://www.npmjs.com/package/easy-monitor">官网</a></p><h2 id="10-3-Node性能优化"><a href="#10-3-Node性能优化" class="headerlink" title="10.3 Node性能优化"></a>10.3 Node性能优化</h2><p>关于Node的性能优化的方式有如下几个：</p><ul><li>使用最新版本Node.js</li><li>正确使用流 Stream</li><li>代码层面优化</li><li>内存管理优化</li></ul><h3 id="10-3-1-使用最新版本Node-js"><a href="#10-3-1-使用最新版本Node-js" class="headerlink" title="10.3.1 使用最新版本Node.js"></a>10.3.1 使用最新版本Node.js</h3><p>每个版本的性能提升主要来自于两个方面：</p><ul><li>V8 的版本更新</li><li>Node.js 内部代码的更新优化</li></ul><h3 id="10-3-2-正确使用流"><a href="#10-3-2-正确使用流" class="headerlink" title="10.3.2 正确使用流"></a>10.3.2 正确使用流</h3><p>在Node中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">http</span> = require(<span class="hljs-string">&#x27;http&#x27;</span>)<span class="hljs-comment">;</span><br>const <span class="hljs-attr">fs</span> = require(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-comment">;</span><br><br>// 错误方式<br>http.createServer(function (req, res) &#123;<br>    fs.readFile(__dirname + &#x27;/data.txt&#x27;, function (err, data) &#123;<br>        res.end(data)<span class="hljs-comment">;</span><br>    &#125;)<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br><br>// 正确方式<br>http.createServer(function (req, res) &#123;<br>    const <span class="hljs-attr">stream</span> = fs.createReadStream(__dirname + <span class="hljs-string">&#x27;/data.txt&#x27;</span>)<span class="hljs-comment">;</span><br>    stream.pipe(res)<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="10-3-3-代码层面优化"><a href="#10-3-3-代码层面优化" class="headerlink" title="10.3.3 代码层面优化"></a>10.3.3 代码层面优化</h3><p>合并查询，将多次查询合并一次，减少数据库的查询次数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 错误方式</span><br><span class="hljs-keyword">for</span> user_id <span class="hljs-keyword">in</span> userIds <br>     <span class="hljs-keyword">let</span> account = user_account.<span class="hljs-title function_">findOne</span>(user_id)<br><br><span class="hljs-comment">// 正确方式</span><br><span class="hljs-keyword">const</span> user_account_map = &#123;&#125;  <br> <span class="hljs-comment">// 注意这个对象将会消耗大量内存。</span><br>user_account.<span class="hljs-title function_">find</span>(user_id <span class="hljs-keyword">in</span> user_ids).<span class="hljs-title function_">forEach</span>(<span class="hljs-params">account</span>)&#123;<br>    user_account_map[account.<span class="hljs-property">user_id</span>] =  account<br>&#125;<br><span class="hljs-keyword">for</span> user_id <span class="hljs-keyword">in</span> userIds <br>    <span class="hljs-keyword">var</span> account = user_account_map[user_id]<br></code></pre></td></tr></table></figure><h3 id="10-3-4-内存管理优化"><a href="#10-3-4-内存管理优化" class="headerlink" title="10.3.4 内存管理优化"></a>10.3.4 内存管理优化</h3><p>在 V8 中，主要将内存分为新生代和老生代两代：</p><ul><li><strong>新生代</strong>：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。</li><li><strong>老生代</strong>：对象存活时间较长。经历过一次或多次垃圾回收的对象。</li></ul><p>若新生代内存空间不够，直接分配到老生代。通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低，比如下面的例子。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini">const <span class="hljs-attr">buffer</span> = fs.readFileSync(__dirname + <span class="hljs-string">&#x27;/source/index.htm&#x27;</span>)<span class="hljs-comment">;</span><br><br>app.use(<br>    mount(&#x27;/&#x27;, async (ctx) =&gt; &#123;<br>        <span class="hljs-attr">ctx.status</span> = <span class="hljs-number">200</span><span class="hljs-comment">;</span><br>        <span class="hljs-attr">ctx.type</span> = <span class="hljs-string">&#x27;html&#x27;</span><span class="hljs-comment">;</span><br>        <span class="hljs-attr">ctx.body</span> = buffer<span class="hljs-comment">;</span><br>        leak.push(fs.readFileSync(__dirname + &#x27;/source/index.htm&#x27;))<span class="hljs-comment">;</span><br>    &#125;)<br>)<span class="hljs-comment">;</span><br><br>const <span class="hljs-attr">leak</span> = []<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>当leak的内存非常大的时候，就有可能造成内存泄露，应当避免这样的操作。</p><p>减少内存使用，可以明显的提高服务性能。而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作。例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新new这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动。而使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中，从而避免重读的初始化操作，从而提高框架的性能。</p><p>[1]. <a href="https://juejin.cn/post/7028781282683256869?searchId=20240111163258C25491133FA9C1A5F289">前端Node.js面试题</a></p>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吐血整理-再来一打Webpack面试题</title>
    <link href="/2024/04/24/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86-%E5%86%8D%E6%9D%A5%E4%B8%80%E6%89%93Webpack%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/04/24/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86-%E5%86%8D%E6%9D%A5%E4%B8%80%E6%89%93Webpack%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>「观感度：🌟🌟🌟🌟🌟」</strong></p><p><strong>「口味：清蒸鲈鱼」</strong></p><p><strong>「烹饪时间：15min」</strong></p><p>本文已收录在<code>Github</code> <a href="https://github.com/Geekhyt/front-end-canteen/" title="https://github.com/Geekhyt/front-end-canteen/">github.com&#x2F;Geekhyt</a></p><p>从头发的浓密程度和干练的走路姿势我察觉到，面前坐着的这位面试官也是一把好手。我像以往一样，准备花3分钟的时间进行自我介绍。在此期间，我的目光被16寸的MacBook Pro所吸引，这次的自我介绍我做足了准备，很有信心征服面试官。不出我所料，面试官被我引入了我擅长的领域。</p><blockquote><p>❝</p><p>看来你对Webpack很熟悉，那我来考考你</p><p>❞</p></blockquote><h2 id="0-有哪些常见的Loader？你用过哪些Loader？"><a href="#0-有哪些常见的Loader？你用过哪些Loader？" class="headerlink" title="0.有哪些常见的Loader？你用过哪些Loader？"></a>0.有哪些常见的Loader？你用过哪些Loader？</h2><p>(我开始熟悉的报起了菜名)</p><ul><li><p><code>raw-loader</code>：加载文件原始内容（utf-8）</p></li><li><p><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</p></li><li><p><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</p></li><li><p><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试</p></li><li><p><code>svg-inline-loader</code>：将压缩后的 SVG 内容注入代码中</p></li><li><p><code>image-loader</code>：加载并且压缩图片文件</p></li><li><p><code>json-loader</code> 加载 JSON 文件（默认包含）</p></li><li><p><code>handlebars-loader</code>: 将 Handlebars 模版编译成函数并返回</p></li><li><p><code>babel-loader</code>：把 ES6 转换成 ES5</p></li><li><p><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript</p></li><li><p><code>awesome-typescript-loader</code>：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</p></li><li><p><code>sass-loader</code>：将SCSS&#x2F;SASS代码转换成CSS</p></li><li><p><code>css-loader</code>：加载 CSS，支持模块化、压缩、文件导入等特性</p></li><li><p><code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</p></li><li><p><code>postcss-loader</code>：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</p></li><li><p><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</p></li><li><p><code>tslint-loader</code>：通过 TSLint检查 TypeScript 代码</p></li><li><p><code>mocha-loader</code>：加载 Mocha 测试用例的代码</p></li><li><p><code>coverjs-loader</code>：计算测试的覆盖率</p></li><li><p><code>vue-loader</code>：加载 Vue.js 单文件组件</p></li><li><p><code>i18n-loader</code>: 国际化</p></li><li><p><code>cache-loader</code>: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</p></li></ul><p>更多 Loader 请参考<a href="https://webpack.docschina.org/loaders/" title="https://webpack.docschina.org/loaders/">官网</a></p><p>(面试官：挺好，知道的还挺多)</p><h2 id="1-有哪些常见的Plugin？你用过哪些Plugin？"><a href="#1-有哪些常见的Plugin？你用过哪些Plugin？" class="headerlink" title="1.有哪些常见的Plugin？你用过哪些Plugin？"></a>1.有哪些常见的Plugin？你用过哪些Plugin？</h2><p>(这大兄弟好像听上瘾了，继续开启常规操作)</p><ul><li><p><code>define-plugin</code>：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</p></li><li><p><code>ignore-plugin</code>：忽略部分文件</p></li><li><p><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)</p></li><li><p><code>web-webpack-plugin</code>：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</p></li><li><p><code>uglifyjs-webpack-plugin</code>：不支持 ES6 压缩 (Webpack4 以前)</p></li><li><p><code>terser-webpack-plugin</code>: 支持压缩 ES6 (Webpack4)</p></li><li><p><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度</p></li><li><p><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)</p></li><li><p><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能</p></li><li><p><code>clean-webpack-plugin</code>: 目录清理</p></li><li><p><code>ModuleConcatenationPlugin</code>: 开启 Scope Hoisting</p></li><li><p><code>speed-measure-webpack-plugin</code>: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</p></li><li><p><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</p></li></ul><p>更多 Plugin 请参考<a href="https://webpack.docschina.org/plugins/" title="https://webpack.docschina.org/plugins/">官网</a></p><p>(Double Kill)</p><h2 id="2-那你再说一说Loader和Plugin的区别？"><a href="#2-那你再说一说Loader和Plugin的区别？" class="headerlink" title="2.那你再说一说Loader和Plugin的区别？"></a>2.那你再说一说Loader和Plugin的区别？</h2><p>(就知道你会问这个，我用手掩盖着嘴角的微笑)</p><p><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p><p><code>Plugin</code> 就是插件，基于事件流框架 <code>Tapable</code>，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p><code>Loader</code> 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p><p><code>Plugin</code> 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p><h2 id="3-Webpack构建流程简单说一下"><a href="#3-Webpack构建流程简单说一下" class="headerlink" title="3.Webpack构建流程简单说一下"></a>3.Webpack构建流程简单说一下</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ul><li><p><code>初始化参数</code>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</p></li><li><p><code>开始编译</code>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</p></li><li><p><code>确定入口</code>：根据配置中的 entry 找出所有的入口文件</p></li><li><p><code>编译模块</code>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</p></li><li><p><code>完成模块编译</code>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</p></li><li><p><code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</p></li><li><p><code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</p></li></ul><p>在以上过程中，<code>Webpack</code> 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><p>简单说</p><ul><li><p>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler</p></li><li><p>编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</p></li><li><p>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</p></li></ul><p>对源码感兴趣的同学可以移步我的另一篇专栏<a href="https://juejin.cn/post/6844904046294204429" title="https://juejin.cn/post/6844904046294204429">从源码窥探Webpack4.x原理</a></p><h2 id="4-使用webpack开发时，你用过哪些可以提高效率的插件？"><a href="#4-使用webpack开发时，你用过哪些可以提高效率的插件？" class="headerlink" title="4.使用webpack开发时，你用过哪些可以提高效率的插件？"></a>4.使用webpack开发时，你用过哪些可以提高效率的插件？</h2><p>(这道题还蛮注重实际，用户的体验还是要从小抓起的)</p><ul><li><p><code>webpack-dashboard</code>：可以更友好的展示相关打包信息。</p></li><li><p><code>webpack-merge</code>：提取公共配置，减少重复配置代码</p></li><li><p><code>speed-measure-webpack-plugin</code>：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。</p></li><li><p><code>size-plugin</code>：监控资源体积变化，尽早发现问题</p></li><li><p><code>HotModuleReplacementPlugin</code>：模块热替换</p></li></ul><h2 id="5-source-map是什么？生产环境怎么用？"><a href="#5-source-map是什么？生产环境怎么用？" class="headerlink" title="5.source map是什么？生产环境怎么用？"></a>5.source map是什么？生产环境怎么用？</h2><p><code>source map</code> 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。</p><p>map文件只要不打开开发者工具，浏览器是不会加载的。</p><p>线上环境一般有三种处理方案：</p><ul><li><p><code>hidden-source-map</code>：借助第三方错误监控平台 Sentry 使用</p></li><li><p><code>nosources-source-map</code>：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高</p></li><li><p><code>sourcemap</code>：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</p></li></ul><p>注意：避免在生产中使用 <code>inline-</code> 和 <code>eval-</code>，因为它们会增加 bundle 体积大小，并降低整体性能。</p><h2 id="6-模块打包原理知道吗？"><a href="#6-模块打包原理知道吗？" class="headerlink" title="6.模块打包原理知道吗？"></a>6.模块打包原理知道吗？</h2><p>Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。</p><h2 id="7-文件监听原理呢？"><a href="#7-文件监听原理呢？" class="headerlink" title="7.文件监听原理呢？"></a>7.文件监听原理呢？</h2><p>在发现源码发生变化时，自动重新构建出新的输出文件。</p><p>Webpack开启监听模式，有两种方式：</p><ul><li>启动 webpack 命令时，带上 –watch 参数</li><li>在配置 webpack.config.js 中设置 watch:true</li></ul><p>缺点：每次需要手动刷新浏览器</p><p>原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 <code>aggregateTimeout</code> 后再执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">module.export = &#123;    // 默认false,也就是不开启    watch: true,    // 只有开启监听模式时，watchOptions才有意义    watchOptions: &#123;        // 默认为空，不监听的文件或者文件夹，支持正则匹配        ignored: /node_modules/,        // 监听到变化发生后会等300ms再去执行，默认300ms        aggregateTimeout:300,        // 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次        poll:1000    &#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="8-说一下-Webpack-的热更新原理吧"><a href="#8-说一下-Webpack-的热更新原理吧" class="headerlink" title="8.说一下 Webpack 的热更新原理吧"></a>8.说一下 Webpack 的热更新原理吧</h2><p>(敲黑板，这道题必考)</p><p><code>Webpack</code> 的热更新又称热替换（<code>Hot Module Replacement</code>），缩写为 <code>HMR</code>。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 <code>Websocket</code>，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 <code>Ajax</code> 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 <code>jsonp</code> 请求获取该chunk的增量更新。</p><p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 <code>HotModulePlugin</code> 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像<code>react-hot-loader</code> 和 <code>vue-loader</code> 都是借助这些 API 实现 HMR。</p><p>细节请参考<a href="https://zhuanlan.zhihu.com/p/30669007" title="https://zhuanlan.zhihu.com/p/30669007">Webpack HMR 原理解析</a></p><p>(面试官：不错不错，小伙子表达能力不错)</p><p>(基操，勿6)</p><h2 id="9-如何对bundle体积进行监控和分析？"><a href="#9-如何对bundle体积进行监控和分析？" class="headerlink" title="9.如何对bundle体积进行监控和分析？"></a>9.如何对bundle体积进行监控和分析？</h2><p><code>VSCode</code> 中有一个插件 <code>Import Cost</code> 可以帮助我们对引入模块的大小进行实时监测，还可以使用 <code>webpack-bundle-analyzer</code> 生成 <code>bundle</code> 的模块组成图，显示所占体积。</p><p><code>bundlesize</code> 工具包可以进行自动化资源体积监控。</p><h2 id="10-文件指纹是什么？怎么用？"><a href="#10-文件指纹是什么？怎么用？" class="headerlink" title="10.文件指纹是什么？怎么用？"></a>10.文件指纹是什么？怎么用？</h2><p>文件指纹是打包后输出的文件名的后缀。</p><ul><li><p><code>Hash</code>：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改</p></li><li><p><code>Chunkhash</code>：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash</p></li><li><p><code>Contenthash</code>：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变</p></li></ul><h3 id="JS的文件指纹设置"><a href="#JS的文件指纹设置" class="headerlink" title="JS的文件指纹设置"></a>JS的文件指纹设置</h3><p>设置 output 的 filename，用 chunkhash。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <br>    <span class="hljs-attr">entry</span>: &#123;        <br>        <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./scr/app.js&#x27;</span>,        <br>        <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;./src/search.js&#x27;</span>    <br>    &#125;,    <br>    <span class="hljs-attr">output</span>: &#123;        <br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name][chunkhash:8].js&#x27;</span>,        <br>        <span class="hljs-attr">path</span>:__dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS的文件指纹设置"><a href="#CSS的文件指纹设置" class="headerlink" title="CSS的文件指纹设置"></a>CSS的文件指纹设置</h3><p>设置 MiniCssExtractPlugin 的 filename，使用 contenthash。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <br>    <span class="hljs-attr">entry</span>: &#123;        <br>        <span class="hljs-attr">app</span>: <span class="hljs-string">&#x27;./scr/app.js&#x27;</span>,        <br>        <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;./src/search.js&#x27;</span>    <br>    &#125;,    <br>    <span class="hljs-attr">output</span>: &#123;        <br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name][chunkhash:8].js&#x27;</span>,        <br>        <span class="hljs-attr">path</span>:__dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>    <br>    &#125;,    <br>    <span class="hljs-attr">plugins</span>:[        <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;            <br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">`[name][contenthash:8].css`</span>        <br>        &#125;)    <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图片的文件指纹设置"><a href="#图片的文件指纹设置" class="headerlink" title="图片的文件指纹设置"></a>图片的文件指纹设置</h3><p>设置file-loader的name，使用hash。</p><p>占位符名称及含义</p><ul><li>ext 资源后缀名</li><li>name 文件名称</li><li>path 文件的相对路径</li><li>folder 文件所在的文件夹</li><li>contenthash 文件的内容hash，默认是md5生成</li><li>hash 文件内容的hash，默认是md5生成</li><li>emoji 一个随机的指代文件内容的emoj</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <br>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    <br>    <span class="hljs-attr">output</span>: &#123;        <br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,        <br>        <span class="hljs-attr">path</span>:path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)    <br>    &#125;,   <br>    <span class="hljs-attr">module</span>:&#123;        <br>        <span class="hljs-attr">rules</span>:[&#123;            <br>            <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.(png|svg|jpg|gif)$/</span>,            <br>            <span class="hljs-attr">use</span>:[&#123;                <br>                <span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;file-loader&#x27;</span>,                <br>                <span class="hljs-attr">options</span>:&#123;                    <br>                    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;img/[name][hash:8].[ext]&#x27;</span>                <br>                &#125;            <br>            &#125;]        <br>        &#125;]    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？"><a href="#11-在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？" class="headerlink" title="11.在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？"></a>11.在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？</h2><p>可以使用 <code>enforce</code> 强制执行 <code>loader</code> 的作用顺序，<code>pre</code> 代表在所有正常 loader 之前执行，<code>post</code> 是所有 loader 之后执行。(inline 官方不推荐使用)</p><h2 id="12-如何优化-Webpack-的构建速度？"><a href="#12-如何优化-Webpack-的构建速度？" class="headerlink" title="12.如何优化 Webpack 的构建速度？"></a>12.如何优化 Webpack 的构建速度？</h2><p>(这个问题就像能不能说一说<strong>「从URL输入到页面显示发生了什么」</strong>一样）</p><p>(我只想说：您希望我讲多长时间呢？)</p><p>(面试官：。。。)</p><ul><li><p>使用<code>高版本</code>的 Webpack 和 Node.js</p></li><li><p><code>多进程/多实例构建</code>：HappyPack(不维护了)、thread-loader</p></li><li><p><code>压缩代码</code></p><ul><li>多进程并行压缩<ul><li>webpack-paralle-uglify-plugin</li><li>uglifyjs-webpack-plugin 开启 parallel 参数 (不支持ES6)</li><li>terser-webpack-plugin 开启 parallel 参数</li></ul></li><li>通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。</li></ul></li><li><p><code>图片压缩</code></p><ul><li>使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)</li><li>配置 image-webpack-loader</li></ul></li><li><p><code>缩小打包作用域</code>：</p><ul><li>exclude&#x2F;include (确定 loader 规则范围)</li><li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li><li>resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)</li><li>resolve.extensions 尽可能减少后缀尝试的可能性</li><li>noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li><li>IgnorePlugin (完全排除模块)</li><li>合理使用alias</li></ul></li><li><p><code>提取页面公共资源</code>：</p><ul><li>基础包分离：<ul><li>使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中</li><li>使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件</li></ul></li></ul></li><li><p><code>DLL</code>：</p><ul><li>使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。</li><li>HashedModuleIdsPlugin 可以解决模块数字id问题</li></ul></li><li><p><code>充分利用缓存提升二次构建速度</code>：</p><ul><li>babel-loader 开启缓存</li><li>terser-webpack-plugin 开启缓存</li><li>使用 cache-loader 或者 hard-source-webpack-plugin</li></ul></li><li><p><code>Tree shaking</code></p><ul><li>打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率</li><li>禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking</li><li>使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码<ul><li>purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)</li></ul></li></ul></li><li><p><code>Scope hoisting</code></p><ul><li>构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突</li><li>必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法</li></ul></li><li><p><code>动态Polyfill</code></p><ul><li>建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。 (部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)</li></ul></li></ul><p>更多优化请参考<a href="https://www.webpackjs.com/guides/build-performance/" title="https://www.webpackjs.com/guides/build-performance/">官网-构建性能</a></p><h2 id="13-你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？"><a href="#13-你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？" class="headerlink" title="13.你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？"></a>13.你刚才也提到了代码分割，那代码分割的本质是什么？有什么意义呢？</h2><p>代码分割的本质其实就是在<code>源代码直接上线</code>和<code>打包成唯一脚本main.bundle.js</code>这两种极端方案之间的一种更适合实际场景的中间状态。</p><p><code>阿卡丽：荣耀剑下取，均衡乱中求</code></p><p><strong>「用可接受的服务器性能压力增加来换取更好的用户体验。」</strong></p><p>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。</p><p>打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。</p><p>(Easy peezy right)</p><h2 id="14-是否写过Loader？简单描述一下编写loader的思路？"><a href="#14-是否写过Loader？简单描述一下编写loader的思路？" class="headerlink" title="14.是否写过Loader？简单描述一下编写loader的思路？"></a>14.是否写过Loader？简单描述一下编写loader的思路？</h2><p>Loader 支持链式调用，所以开发上需要严格遵循“单一职责”，每个 Loader 只负责自己需要负责的事情。</p><p><a href="https://www.webpackjs.com/api/loaders/" title="https://www.webpackjs.com/api/loaders/">Loader的API</a> 可以去官网查阅</p><ul><li>Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用</li><li>Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw &#x3D; true 告诉 Webpack 该 Loader 是否需要二进制数据</li><li>尽可能的异步化 Loader，如果计算量很小，同步也可以</li><li>Loader 是无状态的，我们不应该在 Loader 中保留状态</li><li>使用 loader-utils 和 schema-utils 为我们提供的实用工具</li><li>加载本地 Loader 方法<ul><li>Npm link</li><li>ResolveLoader</li></ul></li></ul><h2 id="15-是否写过Plugin？简单描述一下编写Plugin的思路？"><a href="#15-是否写过Plugin？简单描述一下编写Plugin的思路？" class="headerlink" title="15.是否写过Plugin？简单描述一下编写Plugin的思路？"></a>15.是否写过Plugin？简单描述一下编写Plugin的思路？</h2><p>webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在特定的阶段钩入想要添加的自定义功能。Webpack 的 Tapable 事件流机制保证了插件的有序性，使得整个系统扩展性良好。</p><p><a href="https://www.webpackjs.com/api/plugins/" title="https://www.webpackjs.com/api/plugins/">Plugin的API</a> 可以去官网查阅</p><ul><li>compiler 暴露了和 Webpack 整个生命周期相关的钩子</li><li>compilation 暴露了与模块和依赖有关的粒度更小的事件钩子</li><li>插件需要在其原型上绑定apply方法，才能访问 compiler 实例</li><li>传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件</li><li>找出合适的事件点去完成想要的功能<ul><li>emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)</li><li>watch-run 当依赖的文件发生变化时会触发</li></ul></li><li>异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住</li></ul><h2 id="16-聊一聊Babel原理吧"><a href="#16-聊一聊Babel原理吧" class="headerlink" title="16.聊一聊Babel原理吧"></a>16.聊一聊Babel原理吧</h2><p>大多数JavaScript Parser遵循 <code>estree</code> 规范，Babel 最初基于 <code>acorn</code> 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：</p><ul><li>解析：将代码转换成 AST<ul><li>词法分析：将代码(字符串)分割为token流，即语法单元成的数组</li><li>语法分析：分析token流(上面生成的数组)并生成 AST</li></ul></li><li>转换：访问 AST 的节点进行变换操作生产新的 AST<ul><li><a href="https://github.com/NervJS/taro/blob/master/packages/taro-transformer-wx/src/index.ts#L15" title="https://github.com/NervJS/taro/blob/master/packages/taro-transformer-wx/src/index.ts#L15">Taro</a>就是利用 babel 完成的小程序语法转换</li></ul></li><li>生成：以新的 AST 为基础生成代码</li></ul><p>想了解如何一步一步实现一个编译器的同学可以移步 Babel 官网曾经推荐的开源项目 <a href="https://github.com/jamiebuilds/the-super-tiny-compiler" title="https://github.com/jamiebuilds/the-super-tiny-compiler">the-super-tiny-compiler</a></p><blockquote><p>❝</p><p>面试官：(我听的口渴了，咱们休息一会，一会进行下半场)</p><p>❞</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>深入浅出 Webpack</p></li><li><p>Webpack 实战</p></li><li><p>玩转 Webpack</p></li></ul><p>[1]. <a href="https://juejin.cn/post/6844904094281236487?searchId=202401111631534861C267C16F27AAFEC6">「吐血整理」再来一打Webpack面试题</a></p>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Commonjs和EsModule区别详解</title>
    <link href="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>今天我们来深度分析一下 <code>Commonjs</code> 和 <code>Es Module</code>，希望通过本文的学习，能够让大家彻底明白 <code>Commonjs</code> 和 <code>Es Module</code> 原理，能够一次性搞定面试中遇到的大部分有关 <code>Commonjs</code> 和 <code>Es Module</code> 的问题。</p><p>老规矩我们带上疑问开始今天的分析🤔🤔🤔：</p><ul><li><p>1 Commonjs 和 Es Module 有什么区别 ？</p></li><li><p>2 Commonjs 如何解决的循环引用问题 ？</p></li><li><p>3 既然有了 <code>exports</code>，为何又出了 <code>module.exports</code>? 既生瑜，何生亮 ？</p></li><li><p>4 <code>require</code> 模块查找机制 ？</p></li><li><p>5 Es Module 如何解决循环引用问题 ？</p></li><li><p>6 <code>exports = &#123;&#125;</code> 这种写法为何无效 ？</p></li><li><p>7 关于 <code>import()</code> 的动态引入 ？</p></li><li><p>8 Es Module 如何改变模块下的私有变量 ？</p></li><li><p>9 …</p></li></ul><blockquote><p>ps:由于作者前一段时间在写《React进阶实践指南》小册，没有时间持续输出高质量文章，接下来我会回归创作高质量技术文章，送人玫瑰，手有余香，希望阅读的朋友能给作者点个赞👍，鼓励我持续创作。</p></blockquote><h2 id="二-模块化"><a href="#二-模块化" class="headerlink" title="二 模块化"></a>二 模块化</h2><p>早期 JavaScript 开发很容易存在<strong>全局污染</strong>和<strong>依赖管理</strong>混乱问题。这些问题在多人开发前端应用的情况下变得更加棘手。我这里例举一个很常见的场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">&lt;body&gt;  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;./home.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;./list.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>如上在没有模块化的前提下，如果在 <code>html</code> 中这么写，那么就会暴露一系列问题。</p><ul><li><strong>全局污染</strong></li></ul><p>没有模块化，那么 <code>script</code> 内部的变量是可以相互污染的。比如有一种场景，如上 <code>./index.js</code> 文件和 <code>./list.js</code> 文件为小 A 开发的，<code>./home.js</code> 为小 B 开发的。</p><p>小 A 在 <code>index.js</code>中声明 name 属性是一个字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">var name = &#x27;我不是外星人&#x27;<br></code></pre></td></tr></table></figure><p>然后小 A 在 <code>list.js</code> 中，引用 name 属性，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">console.log(name)<br></code></pre></td></tr></table></figure><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640.webp" alt="图片"></p><p>1.jpg</p><p>打印却发现 name 竟然变成了一个函数。刚开始小 A 不知所措，后来发现在小 B 开发的 <code>home.js</code> 文件中这么写道：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">function name()&#123;    //...&#125;<br></code></pre></td></tr></table></figure><p>而且这个 name 方法被引用了多次，导致一系列的连锁反应。</p><p>上述例子就是没有使用模块化开发，造成的全局污染的问题，每个加载的 js 文件都共享变量。当然在实际的项目开发中，可以使用匿名函数自执行的方式，形成独立的块级作用域解决这个问题。</p><p>只需要在 home.js 中这么写道：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">(function ()&#123;    function name()&#123;        //...    &#125;&#125;)()<br></code></pre></td></tr></table></figure><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-17134272146311.webp" alt="图片"></p><p>2.jpg</p><p>这样小 A 就能正常在 <code>list.js</code> 中获取 name 属性。但是这只是一个 <code>demo</code> ，我们不能保证在实际开发中情况会更加复杂。所以不使用模块开发会暴露出很多风险。</p><ul><li><strong>依赖管理</strong></li></ul><p>依赖管理也是一个难以处理的问题。还是如上的例子，正常情况下，执行 js 的先后顺序就是 script 标签排列的前后顺序。那么如何三个 js 之间有依赖关系，那么应该如何处理呢？</p><p>假设三个 js 中，都有一个公共方法 <code>fun1</code> ， <code>fun2</code> ， <code>fun3</code>。三者之间的依赖关系如下图所示。</p><ul><li>下层 js 能调用上层 js 的方法，但是上层 js 无法调用下层 js 的方法。</li></ul><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-17134272146312.webp" alt="图片"></p><p>3.jpg</p><p>所以就需要模块化来解决上述的问题，今天我们就重点讲解一下前端模块化的两个重要方案：<strong>Commonjs</strong> 和 <strong>Es Module</strong></p><h2 id="三-Commonjs"><a href="#三-Commonjs" class="headerlink" title="三 Commonjs"></a>三 Commonjs</h2><p><code>Commonjs</code> 的提出，弥补 Javascript 对于模块化，没有统一标准的缺陷。nodejs 借鉴了 <code>Commonjs</code> 的 Module ，实现了良好的模块化管理。</p><p>目前 <code>commonjs</code> 广泛应用于以下几个场景：</p><ul><li><p><code>Node</code> 是 CommonJS 在服务器端一个具有代表性的实现；</p></li><li><p><code>Browserify</code> 是 CommonJS 在浏览器中的一种实现；</p></li><li><p><code>webpack</code> 打包工具对 CommonJS 的支持和转换；也就是前端应用也可以在编译之前，尽情使用 CommonJS 进行开发。</p></li></ul><h3 id="1-commonjs-使用与原理"><a href="#1-commonjs-使用与原理" class="headerlink" title="1 commonjs 使用与原理"></a>1 commonjs 使用与原理</h3><p>在使用  规范下，有几个显著的特点。</p><ul><li><p>在 <code>commonjs</code> 中每一个 js 文件都是一个单独的模块，我们可以称之为 module；</p></li><li><p>该模块中，包含 CommonJS 规范的核心变量: exports、module.exports、require；</p></li><li><p>exports 和 module.exports 可以负责对模块中的内容进行导出；</p></li><li><p>require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；</p></li></ul><h4 id="commonjs-使用初体验"><a href="#commonjs-使用初体验" class="headerlink" title="commonjs 使用初体验"></a>commonjs 使用初体验</h4><p><strong>导出</strong>：我们先尝试这导出一个模块：</p><p><strong><code>hello.js</code>中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">let name = &#x27;《React进阶实践指南》&#x27;module.exports = function sayName  ()&#123;    return name&#125;<br></code></pre></td></tr></table></figure><p><strong>导入</strong>：接下来简单的导入：</p><p><strong><code>home.js</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const sayName = require(&#x27;./hello.js&#x27;)module.exports = function say()&#123;    return &#123;        name:sayName(),        author:&#x27;我不是外星人&#x27;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>如上就是 Commonjs 最简单的实现，那么暴露出两个问题：</p><ul><li><p>如何解决变量污染的问题。</p></li><li><p>module.exports，exports，require 三者是如何工作的？又有什么关系？</p></li></ul><h4 id="commonjs-实现原理"><a href="#commonjs-实现原理" class="headerlink" title="commonjs 实现原理"></a>commonjs 实现原理</h4><p>首先从上述得知每个模块文件上存在 <code>module</code>，<code>exports</code>，<code>require</code>三个变量，然而这三个变量是没有被定义的，但是我们可以在 Commonjs 规范下每一个 js 模块上直接使用它们。在 nodejs 中还存在 <code>__filename</code> 和 <code>__dirname</code> 变量。</p><p>如上每一个变量代表什么意思呢：</p><ul><li><p><code>module</code> 记录当前模块信息。</p></li><li><p><code>require</code> 引入模块的方法。</p></li><li><p><code>exports</code> 当前模块导出的属性</p></li></ul><p>在编译的过程中，实际 Commonjs 对 js 的代码块进行了首尾包装， 我们以上述的 home.js 为例子🌰，它被包装之后的样子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">(function(exports,require,module,__filename,__dirname)&#123;   const sayName = require(&#x27;./hello.js&#x27;)    module.exports = function say()&#123;        return &#123;            name:sayName(),            author:&#x27;我不是外星人&#x27;        &#125;    &#125;&#125;)<br></code></pre></td></tr></table></figure><ul><li>在 Commonjs 规范下模块中，会形成一个包装函数，我们写的代码将作为包装函数的执行上下文，使用的 <code>require</code> ，<code>exports</code> ，<code>module</code> 本质上是通过形参的方式传递到包装函数中的。</li></ul><p>那么包装函数本质上是什么样子的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">function wrapper (script) &#123;    return &#x27;(function (exports, require, module, __filename, __dirname) &#123;&#x27; +         script +     &#x27;\n&#125;)&#x27;&#125;<br></code></pre></td></tr></table></figure><p>包装函数执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const modulefunction = wrapper(`  const sayName = require(&#x27;./hello.js&#x27;)    module.exports = function say()&#123;        return &#123;            name:sayName(),            author:&#x27;我不是外星人&#x27;        &#125;    &#125;`)<br></code></pre></td></tr></table></figure><ul><li>如上模拟了一个包装函数功能， script 为我们在 js 模块中写的内容，最后返回的就是如上包装之后的函数。当然这个函数暂且是一个字符串。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">runInThisContext(modulefunction)(module.exports, require, module, __filename, __dirname)<br></code></pre></td></tr></table></figure><ul><li>在模块加载的时候，会通过 runInThisContext (可以理解成 eval ) 执行 <code>modulefunction</code> ，传入<code>require</code> ，<code>exports</code> ，<code>module</code> 等参数。最终我们写的 nodejs 文件就这么执行了。</li></ul><p>到此为止，完成了整个模块执行的原理。接下来我们来分析以下 require 文件加载的流程。</p><h3 id="2-require-文件加载流程"><a href="#2-require-文件加载流程" class="headerlink" title="2 require 文件加载流程"></a>2 require 文件加载流程</h3><p>上述说了 commonjs 规范大致的实现原理，接下来我们分析一下， <code>require</code> 如何进行文件的加载的。</p><p>我们还是以 nodejs 为参考，比如如下代码片段中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const fs =      require(&#x27;fs&#x27;)      // ①核心模块const sayName = require(&#x27;./hello.js&#x27;)  //② 文件模块const crypto =  require(&#x27;crypto-js&#x27;)   // ③第三方自定义模块<br></code></pre></td></tr></table></figure><p>如上代码片段中：</p><ul><li><p>① 为 nodejs 底层的核心模块。</p></li><li><p>② 为我们编写的文件模块，比如上述 <code>sayName</code></p></li><li><p>③ 为我们通过 npm 下载的第三方自定义模块，比如 <code>crypto-js</code>。</p></li></ul><p>当 require 方法执行的时候，接收的唯一参数作为一个<strong>标识符</strong> ，Commonjs 下对不同的标识符，处理流程不同，但是<strong>目的相同，都是找到对应的模块</strong>。</p><h4 id="require-加载标识符原则"><a href="#require-加载标识符原则" class="headerlink" title="require 加载标识符原则"></a>require 加载标识符原则</h4><p>首先我们看一下 <code>nodejs</code> 中对标识符的处理原则。</p><ul><li><p>首先像 fs ，http ，path 等标识符，会被作为 nodejs 的<strong>核心模块</strong>。</p></li><li><p><code>./</code> 和 <code>../</code> 作为相对路径的<strong>文件模块</strong>， <code>/</code> 作为绝对路径的<strong>文件模块</strong>。</p></li><li><p>非路径形式也非核心模块的模块，将作为<strong>自定义模块</strong>。</p></li></ul><p><strong>核心模块的处理：</strong></p><p>核心模块的优先级仅次于缓存加载，在 <code>Node</code> 源码编译中，已被编译成二进制代码，所以加载核心模块，加载过程中速度最快。</p><p><strong>路径形式的文件模块处理：</strong></p><p>已 <code>./</code> ，<code>../</code> 和 <code>/</code> 开始的标识符，会被当作文件模块处理。<code>require()</code> 方法会将路径转换成真实路径，并以真实路径作为索引，将编译后的结果缓存起来，第二次加载的时候会更快。至于<strong>怎么缓存</strong>的？我们稍后会讲到。</p><p><strong>自定义模块处理：</strong>自定义模块，一般指的是非核心的模块，它可能是一个文件或者一个包，它的查找会遵循以下原则：</p><ul><li><p>在当前目录下的 <code>node_modules</code> 目录查找。</p></li><li><p>如果没有，在父级目录的 <code>node_modules</code> 查找，如果没有在父级目录的父级目录的 <code>node_modules</code> 中查找。</p></li><li><p>沿着路径向上递归，直到根目录下的 <code>node_modules</code> 目录。</p></li><li><p>在查找过程中，会找 <code>package.json</code> 下 main 属性指向的文件，如果没有  <code>package.json</code> ，在 node 环境下会以此查找 <code>index.js</code> ，<code>index.json</code> ，<code>index.node</code>。</p></li></ul><p>查找流程图如下所示：</p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-17134272146313.webp" alt="图片"></p><p>4.jpg</p><h3 id="3-require-模块引入与处理"><a href="#3-require-模块引入与处理" class="headerlink" title="3 require 模块引入与处理"></a>3 require 模块引入与处理</h3><p>CommonJS 模块同步加载并执行模块文件，CommonJS 模块在执行阶段分析模块依赖，采用<strong>深度优先遍历</strong>（depth-first traversal），执行顺序是父 -&gt; 子 -&gt; 父；</p><p>为了搞清除 require 文件引入流程。我们接下来再举一个例子，这里注意一下细节：</p><ul><li><code>a.js文件</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const getMes = require(&#x27;./b&#x27;)console.log(&#x27;我是 a 文件&#x27;)exports.say = function()&#123;    const message = getMes()    console.log(message)&#125;<br></code></pre></td></tr></table></figure><ul><li><code>b.js</code>文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const say = require(&#x27;./a&#x27;)const  object = &#123;   name:&#x27;《React进阶实践指南》&#x27;,   author:&#x27;我不是外星人&#x27;&#125;console.log(&#x27;我是 b 文件&#x27;)module.exports = function()&#123;    return object&#125;<br></code></pre></td></tr></table></figure><ul><li>主文件<code>main.js</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const a = require(&#x27;./a&#x27;)const b = require(&#x27;./b&#x27;)console.log(&#x27;node 入口文件&#x27;)<br></code></pre></td></tr></table></figure><p>接下来终端输入 <code>node main.js</code> 运行 <code>main.js</code>，效果如下：</p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-17134272146324.webp" alt="图片"></p><p>5.jpg</p><p>从上面的运行结果可以得出以下结论：</p><ul><li><p><code>main.js</code> 和 <code>a.js</code> 模块都引用了 <code>b.js</code> 模块，但是 <code>b.js</code> 模块只执行了一次。</p></li><li><p><code>a.js</code> 模块 和 <code>b.js</code> 模块互相引用，但是没有造成循环引用的情况。</p></li><li><p>执行顺序是父 -&gt; 子 -&gt; 父；</p></li></ul><p><strong>那么 <code>Common.js</code> 规范是如何实现上述效果的呢？</strong></p><h4 id="require-加载原理"><a href="#require-加载原理" class="headerlink" title="require 加载原理"></a>require 加载原理</h4><p>首先为了弄清楚上述两个问题。我们要明白两个感念，那就是 <code>module</code> 和 <code>Module</code>。</p><p><strong><code>module</code></strong> ：在 Node 中每一个 js 文件都是一个 module ，module 上保存了 exports 等信息之外，还有一个 <strong><code>loaded</code></strong> 表示该模块是否被加载。</p><ul><li><p>为 <code>false</code> 表示还没有加载；</p></li><li><p>为 <code>true</code> 表示已经加载</p></li></ul><p><strong><code>Module</code></strong> ：以 nodejs 为例，整个系统运行之后，会用 <code>Module</code> 缓存每一个模块加载的信息。</p><p>require 的源码大致长如下的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">// id 为路径标识符function require(id) &#123;   /* 查找  Module 上有没有已经加载的 js  对象*/   const  cachedModule = Module._cache[id]      /* 如果已经加载了那么直接取走缓存的 exports 对象  */  if(cachedModule)&#123;    return cachedModule.exports  &#125;   /* 创建当前模块的 module  */  const module = &#123; exports: &#123;&#125; ,loaded: false , ...&#125;  /* 将 module 缓存到  Module 的缓存属性中，路径标识符作为 id */    Module._cache[id] = module  /* 加载文件 */  runInThisContext(wrapper(&#x27;module.exports = &quot;123&quot;&#x27;))(module.exports, require, module, __filename, __dirname)  /* 加载完成 *//  module.loaded = true   /* 返回值 */  return module.exports&#125;<br></code></pre></td></tr></table></figure><p>从上面我们总结出一次 <code>require</code> 大致流程是这样的；</p><ul><li><p>require 会接收一个参数——文件标识符，然后分析定位文件，分析过程我们上述已经讲到了，加下来会从 Module 上查找有没有缓存，如果有缓存，那么直接返回缓存的内容。</p></li><li><p>如果没有缓存，会创建一个 module 对象，缓存到 Module 上，然后执行文件，加载完文件，将 loaded 属性设置为 true ，然后返回 module.exports 对象。借此完成模块加载流程。</p></li><li><p>模块导出就是 return 这个变量的其实跟 a &#x3D; b 赋值一样， 基本类型导出的是值， 引用类型导出的是引用地址。</p></li><li><p>exports 和 module.exports 持有相同引用，因为最后导出的是 module.exports， 所以对 exports 进行赋值会导致 exports 操作的不再是 module.exports 的引用。</p></li></ul><h4 id="require-避免重复加载"><a href="#require-避免重复加载" class="headerlink" title="require 避免重复加载"></a>require 避免重复加载</h4><p>从上面我们可以直接得出，require 如何避免重复加载的，首先加载之后的文件的 <code>module</code> 会被缓存到 <code>Module</code> 上，比如一个模块已经 require 引入了 a 模块，如果另外一个模块再次引用 a ，那么会直接读取缓存值 module ，所以无需再次执行模块。</p><p>对应 demo 片段中，首先 <code>main.js</code> 引用了 <code>a.js</code> ，<code>a.js</code> 中 require 了 <code>b.js</code> 此时 <code>b.js</code> 的 module 放入缓存 <code>Module</code> 中，接下来 <code>main.js</code> 再次引用  <code>b.js</code> ，那么直接走的缓存逻辑。所以 b.js 只会执行一次，也就是在 a.js 引入的时候。</p><h4 id="require-避免循环引用"><a href="#require-避免循环引用" class="headerlink" title="require 避免循环引用"></a>require 避免循环引用</h4><p>那么接下来这个循环引用问题，也就很容易解决了。为了让大家更清晰明白，那么我们接下来一起分析整个流程。</p><ul><li><p>① 首先执行 <code>node main.js</code> ，那么开始执行第一行 <code>require(a.js)</code>；</p></li><li><p>② 那么首先判断 <code>a.js</code> 有没有缓存，因为没有缓存，先加入缓存，然后执行文件 a.js （<strong>需要注意 是先加入缓存， 后执行模块内容</strong>）;</p></li><li><p>③ a.js 中执行第一行，引用 b.js。</p></li><li><p>④ 那么判断 <code>b.js</code> 有没有缓存，因为没有缓存，所以加入缓存，然后执行 b.js 文件。</p></li><li><p>⑤ b.js 执行第一行，再一次循环引用 <code>require(a.js)</code> 此时的 a.js 已经加入缓存，直接读取值。接下来打印 <code>console.log(&#39;我是 b 文件&#39;)</code>，导出方法。</p></li><li><p>⑥ b.js 执行完毕，回到 a.js 文件，打印 <code>console.log(&#39;我是 a 文件&#39;)</code>，导出方法。</p></li><li><p>⑦ 最后回到 <code>main.js</code>，打印 <code>console.log(&#39;node 入口文件&#39;)</code> 完成这个流程。</p></li></ul><p>不过这里我们要注意问题：</p><ul><li>如上第 ⑤ 的时候，当执行 b.js 模块的时候，因为 a.js 还没有导出 <code>say</code> 方法，所以 b.js 同步上下文中，获取不到 say。</li></ul><p>我用一幅流程图描述上述过程：</p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-17134272146325.webp" alt="图片"></p><p>15.jpg</p><p>为了进一步验证上面所说的，我们改造一下 <code>b.js</code> 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const say = require(&#x27;./a&#x27;)const  object = &#123;   name:&#x27;《React进阶实践指南》&#x27;,   author:&#x27;我不是外星人&#x27;&#125;console.log(&#x27;我是 b 文件&#x27;)console.log(&#x27;打印 a 模块&#x27; , say)setTimeout(()=&gt;&#123;    console.log(&#x27;异步打印 a 模块&#x27; , say)&#125;,0)module.exports = function()&#123;    return object&#125;<br></code></pre></td></tr></table></figure><p>打印结果：</p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-17134272146326.webp" alt="图片"></p><p>6.jpg</p><ul><li><p>第一次打印 say 为空对象。</p></li><li><p>第二次打印 say 才看到 b.js 导出的方法。</p></li></ul><p>那么如何获取到 say 呢，有两种办法：</p><ul><li><p>一是用动态加载 a.js 的方法，马上就会讲到。</p></li><li><p>二个就是如上放在异步中加载。</p></li></ul><p>我们注意到 a.js 是用 <code>exports.say</code> 方式导出的，如果 a.js 用 module.exports 结果会有所不同。至于有什么不同，为什么？我接下来会讲到。</p><h3 id="4-require-动态加载"><a href="#4-require-动态加载" class="headerlink" title="4 require 动态加载"></a>4 require 动态加载</h3><p>上述我们讲了 <code>require</code> 查找文件和加载流程。接下来介绍 <code>commonjs</code> 规范下的 require 的另外一个特性——<strong>动态加载</strong>。</p><p>require 可以在任意的上下文，动态加载模块。我对上述 a.js 修改。</p><p><code>a.js</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">console.log(&#x27;我是 a 文件&#x27;)exports.say = function()&#123;    const getMes = require(&#x27;./b&#x27;)    const message = getMes()    console.log(message)&#125;<br></code></pre></td></tr></table></figure><p><code>main.js</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const a = require(&#x27;./a&#x27;)a.say()<br></code></pre></td></tr></table></figure><ul><li>如上在 a.js 模块的 say 函数中，用 require 动态加载 b.js 模块。然后执行在 main.js 中执行 a.js 模块的 say 方法。</li></ul><p>打印结果如下：</p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-17134272146327.webp" alt="图片"></p><p>7.jpg</p><p>require 本质上就是一个函数，那么函数可以在任意上下文中执行，来自由地加载其他模块的属性方法。</p><h3 id="5-exports-和-module-exports"><a href="#5-exports-和-module-exports" class="headerlink" title="5 exports 和 module.exports"></a>5 exports 和 module.exports</h3><p>系统分析完 <code>require</code> ，接下来我们分析一下，<code>exports</code> 和 <code>module.exports</code>，首先看一下两个的用法。</p><h4 id="exports-使用"><a href="#exports-使用" class="headerlink" title="exports 使用"></a>exports 使用</h4><p><strong>第一种方式：exports</strong><code>a.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">exports.name = `《React进阶实践指南》`exports.author = `我不是外星人`exports.say = function ()&#123;    console.log(666)&#125;<br></code></pre></td></tr></table></figure><p><strong>引用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const a = require(&#x27;./a&#x27;)console.log(a)<br></code></pre></td></tr></table></figure><p><strong>打印结果：</strong></p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-17134272146328.webp" alt="图片"></p><p>8.jpg</p><ul><li>exports 就是传入到当前模块内的一个对象，本质上就是 <code>module.exports</code>。</li></ul><p><strong>问题：为什么 exports&#x3D;{} 直接赋值一个对象就不可以呢？</strong> 比如我们将如上 <code>a.js</code> 修改一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">exports=&#123;    name:&#x27;《React进阶实践指南》&#x27;,    author:&#x27;我不是外星人&#x27;,    say()&#123;        console.log(666)    &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>打印结果：</strong></p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-17134272146329.webp" alt="图片"></p><p>9.jpg</p><p>理想情况下是通过 <code>exports = &#123;&#125;</code> 直接赋值，不需要在  <code>exports.a = xxx</code>  每一个属性，但是如上我们看到了这种方式是无效的。为什么会这样？实际这个是 js 本身的特性决定的。</p><p>通过上述讲解都知道 exports ， module 和 require 作为形参的方式传入到 js 模块中。我们直接 <code>exports = &#123;&#125;</code>  修改 exports ，等于重新赋值了形参，那么会重新赋值一份，但是不会在引用原来的形参。举一个简单的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">function wrap (myExports)&#123;    myExports=&#123;       name:&#x27;我不是外星人&#x27;   &#125;&#125;let myExports = &#123;    name:&#x27;alien&#x27;&#125;wrap(myExports)console.log(myExports)<br></code></pre></td></tr></table></figure><p><strong>打印：</strong></p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-171342721463210.webp" alt="图片"></p><p>10.jpg</p><p>我们期望修改 myExports ，但是没有任何作用。</p><p>假设 <code>wrap</code> 就是 Commonjs 规范下的包装函数，我们的 js 代码就是包装函数内部的内容。当我们把  myExports 对象传进去，但是直接赋值 <code>myExports = &#123; name:&#39;我不是外星人&#39; &#125;</code> 没有任何作用，相等于内部重新声明一份 <code>myExports</code> 而和外界的 myExports 断绝了关系。所以解释了为什么不能 <code>exports=&#123;...&#125;</code> 直接赋值。</p><p>那么解决上述也容易，只需要函数中像 exports.name 这么写就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">function wrap (myExports)&#123;    myExports.name=&#x27;我不是外星人&#x27;&#125;<br></code></pre></td></tr></table></figure><p><strong>打印：</strong></p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-171342721463211.webp" alt="图片"></p><p>11.jpg</p><h4 id="module-exports-使用"><a href="#module-exports-使用" class="headerlink" title="module.exports 使用"></a>module.exports 使用</h4><p>module.exports 本质上就是 exports ，我们用 module.exports 来实现如上的导出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">module.exports =&#123;    name:&#x27;《React进阶实践指南》&#x27;,    author:&#x27;我不是外星人&#x27;,    say()&#123;        console.log(666)    &#125;&#125;<br></code></pre></td></tr></table></figure><p>module.exports 也可以单独导出一个函数或者一个类。比如如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">module.exports = function ()&#123;    // ...&#125;<br></code></pre></td></tr></table></figure><p>从上述 <code>require</code> 原理实现中，我们知道了 exports 和 module.exports 持有相同引用，因为最后导出的是 module.exports 。那么这就说明在一个文件中，我们最好选择 <code>exports</code> 和 <code>module.exports</code> 两者之一，如果两者同时存在，很可能会造成覆盖的情况发生。比如如下情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">exports.name = &#x27;alien&#x27; // 此时 exports.name 是无效的module.exports =&#123;    name:&#x27;《React进阶实践指南》&#x27;,    author:&#x27;我不是外星人&#x27;,    say()&#123;        console.log(666)    &#125;&#125;<br></code></pre></td></tr></table></figure><ul><li>上述情况下 exports.name 无效，会被 <code>module.exports</code> 覆盖。</li></ul><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h4><p>1 那么问题来了？<strong>既然有了 <code>exports</code>，为何又出了 <code>module.exports</code>?</strong></p><p>答：如果我们不想在 commonjs 中导出对象，而是只导出一个<strong>类或者一个函数</strong>再或者其他属性的情况，那么 <code>module.exports</code> 就更方便了，如上我们知道 <code>exports</code> 会被初始化成一个对象，也就是我们只能在对象上绑定属性，但是我们可以通过 <code>module.exports</code> 自定义导出出对象外的其他类型元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">let a = 1module.exports = a // 导出函数module.exports = [1,2,3] // 导出数组module.exports = function()&#123;&#125; //导出方法<br></code></pre></td></tr></table></figure><p>2 与 <code>exports</code> 相比，<code>module.exports</code> 有什么缺陷 ？</p><p>答：<code>module.exports</code> 当导出一些函数等非对象属性的时候，也有一些风险，就比如循环引用的情况下。对象会保留相同的内存地址，就算一些属性是后绑定的，也能间接通过异步形式访问到。但是如果 module.exports 为一个非对象其他属性类型，在循环引用的时候，就容易造成属性丢失的情况发生了。</p><h2 id="四-Es-Module"><a href="#四-Es-Module" class="headerlink" title="四 Es Module"></a>四 Es Module</h2><p><code>Nodejs</code> 借鉴了 <code>Commonjs</code> 实现了模块化 ，从 <code>ES6</code> 开始， <code>JavaScript</code> 才真正意义上有自己的模块化规范，</p><p>Es Module 的产生有很多优势，比如:</p><ul><li><p>借助 <code>Es Module</code> 的静态导入导出的优势，实现了 <code>tree shaking</code>。</p></li><li><p><code>Es Module</code> 还可以 <code>import()</code> 懒加载方式实现代码分割。</p></li></ul><p>在 <code>Es Module</code> 中用 <code>export</code> 用来导出模块，<code>import</code> 用来导入模块。但是 <code>export</code> 配合 <code>import</code> 会有很多种组合情况，接下来我们逐一分析一下。</p><h3 id="导出-export-和导入-import"><a href="#导出-export-和导入-import" class="headerlink" title="导出 export 和导入 import"></a>导出 export 和导入 import</h3><p>所有通过 export 导出的属性，在 import 中可以通过结构的方式，解构出来。</p><p><strong>export 正常导出，import 导入</strong></p><p>导出模块：<code>a.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const name = &#x27;《React进阶实践指南》&#x27; const author = &#x27;我不是外星人&#x27;export &#123; name, author &#125;export const say = function ()&#123;    console.log(&#x27;hello , world&#x27;)&#125;<br></code></pre></td></tr></table></figure><p>导入模块：<code>main.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">// name , author , say 对应 a.js 中的  name , author , sayimport &#123; name , author , say &#125; from &#x27;./a.js&#x27;<br></code></pre></td></tr></table></figure><ul><li><p>export { }， 与变量名绑定，命名导出。</p></li><li><p>import { } from ‘module’， 导入 <code>module</code> 的命名导出 ，module 为如上的 <code>./a.js</code></p></li><li><p>这种情况下 import { } 内部的变量名称，要与 export { } 完全匹配。</p></li></ul><p><strong>默认导出 export default</strong></p><p>导出模块：<code>a.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const name = &#x27;《React进阶实践指南》&#x27;const author = &#x27;我不是外星人&#x27;const say = function ()&#123;    console.log(&#x27;hello , world&#x27;)&#125;export default &#123;    name,    author,    say&#125; <br></code></pre></td></tr></table></figure><p>导入模块：<code>main.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">import mes from &#x27;./a.js&#x27;console.log(mes) //&#123; name: &#x27;《React进阶实践指南》&#x27;,author:&#x27;我不是外星人&#x27;, say:Function &#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>export default anything</code> 导入 module 的默认导出。<code>anything</code> 可以是函数，属性方法，或者对象。</p></li><li><p>对于引入默认导出的模块，<code>import anyName from &#39;module&#39;</code>， anyName 可以是自定义名称。</p></li></ul><p><strong>混合导入｜导出</strong></p><p>ES6 module 可以使用 export default 和 export 导入多个属性。</p><p>导出模块：<code>a.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">export const name = &#x27;《React进阶实践指南》&#x27;export const author = &#x27;我不是外星人&#x27;export default  function say ()&#123;    console.log(&#x27;hello , world&#x27;)&#125;<br></code></pre></td></tr></table></figure><p>导入模块：<code>main.js</code> 中有几种导入方式：</p><p>第一种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">import theSay , &#123; name, author as  bookAuthor &#125; from &#x27;./a.js&#x27;console.log(    theSay,     // ƒ say() &#123;console.log(&#x27;hello , world&#x27;) &#125;    name,       // &quot;《React进阶实践指南》&quot;    bookAuthor  // &quot;我不是外星人&quot;)<br></code></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">import theSay, * as mes from &#x27;./a&#x27;console.log(    theSay, // ƒ say() &#123; console.log(&#x27;hello , world&#x27;) &#125;    mes // &#123; name:&#x27;《React进阶实践指南》&#x27; , author: &quot;我不是外星人&quot; ，default:  ƒ say() &#123; console.log(&#x27;hello , world&#x27;) &#125; &#125;)<br></code></pre></td></tr></table></figure><ul><li>导出的属性被合并到 <code>mes</code> 属性上， <code>export</code> 被导入到对应的属性上，<code>export default</code> 导出内容被绑定到 <code>default</code> 属性上。<code>theSay</code> 也可以作为被 <code>export default</code> 导出属性。</li></ul><p><strong>重属名导入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">import &#123; bookName as name, say, bookAuthor as author &#125; from &#x27;module&#x27;console.log( bookName , bookAuthor , say ) //《React进阶实践指南》 我不是外星人<br></code></pre></td></tr></table></figure><ul><li>从 module 模块中引入 name ，并重命名为 bookName ，从 module 模块中引入 author ，并重命名为 bookAuthor。然后在当前模块下，使用被重命名的名字。</li></ul><p><strong>重定向导出</strong></p><p>可以把当前模块作为一个中转站，一方面引入 module 内的属性，然后把属性再给导出去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">export * from &#x27;module&#x27; // 第一种方式export &#123; name, author, ..., say &#125; from &#x27;module&#x27; // 第二种方式export &#123; bookName as name, bookAuthor as author, ..., say &#125; from &#x27;module&#x27; //第三种方式<br></code></pre></td></tr></table></figure><ul><li><p>第一种方式：重定向导出 module 中的所有导出属性， 但是不包括 <code>module</code> 内的 <code>default</code> 属性。</p></li><li><p>第二种方式：从 module 中导入 name ，author ，say 再以相同的属性名，导出。</p></li><li><p>第三种方式：从 module 中导入 name ，重属名为 bookName 导出，从 module 中导入 author ，重属名为 bookAuthor 导出，正常导出 say 。</p></li></ul><p><strong>无需导入模块，只运行模块</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">import &#x27;module&#x27; <br></code></pre></td></tr></table></figure><ul><li>执行 module 不导出值  多次调用 <code>module</code> 只运行一次。</li></ul><p><strong>动态导入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const promise = import(&#x27;module&#x27;)<br></code></pre></td></tr></table></figure><ul><li><code>import(&#39;module&#39;)</code>，动态导入返回一个 <code>Promise</code>。为了支持这种方式，需要在 webpack 中做相应的配置处理。</li></ul><h3 id="ES6-module-特性"><a href="#ES6-module-特性" class="headerlink" title="ES6 module 特性"></a>ES6 module 特性</h3><p>接下来我们重点分析一下 ES6 module 一些重要特性。</p><h4 id="1-静态语法"><a href="#1-静态语法" class="headerlink" title="1 静态语法"></a>1 静态语法</h4><p>ES6 module 的引入和导出是静态的，<code>import</code> 会自动提升到代码的顶层 ，<code>import</code> , <code>export</code> 不能放在块级作用域或条件语句中。</p><p>🙅错误写法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">function say()&#123;  import name from &#x27;./a.js&#x27;    export const author = &#x27;我不是外星人&#x27;&#125;<br></code></pre></td></tr></table></figure><p>🙅错误写法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">isexport &amp;&amp;  export const  name = &#x27;《React进阶实践指南》&#x27;<br></code></pre></td></tr></table></figure><p>这种静态语法，在编译过程中确定了导入和导出的关系，所以更方便去查找依赖，更方便去 <code>tree shaking</code> (摇树) ， 可以使用 lint 工具对模块依赖进行检查，可以对导入导出加上类型信息进行静态的类型检查。</p><p>import 的导入名不能为字符串或在判断语句，下面代码是错误的</p><p>🙅错误写法三：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">import &#x27;defaultExport&#x27; from &#x27;module&#x27;let name = &#x27;Export&#x27;import &#x27;default&#x27; + name from &#x27;module&#x27;<br></code></pre></td></tr></table></figure><h4 id="2-执行特性"><a href="#2-执行特性" class="headerlink" title="2 执行特性"></a>2 执行特性</h4><p>ES6 module 和 Common.js 一样，对于相同的 js 文件，会保存静态属性。</p><p>但是与 Common.js 不同的是 ，<code>CommonJS</code> 模块同步加载并执行模块文件，ES6 模块提前加载并执行模块文件，ES6 模块在预处理阶段分析模块依赖，在执行阶段执行模块，两个阶段都采用深度优先遍历，执行顺序是子 -&gt; 父。</p><p>为了验证这一点，看一下如下 demo。</p><p><strong><code>main.js</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">console.log(&#x27;main.js开始执行&#x27;)import say from &#x27;./a&#x27;import say1 from &#x27;./b&#x27;console.log(&#x27;main.js执行完毕&#x27;)<br></code></pre></td></tr></table></figure><p><strong><code>a.js</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">import b from &#x27;./b&#x27;console.log(&#x27;a模块加载&#x27;)export default  function say ()&#123;    console.log(&#x27;hello , world&#x27;)&#125;<br></code></pre></td></tr></table></figure><p><strong><code>b.js</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">console.log(&#x27;b模块加载&#x27;)export default function sayhello()&#123;    console.log(&#x27;hello,world&#x27;)&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>main.js</code> 和 <code>a.js</code> 都引用了 <code>b.js</code> 模块，但是 b 模块也只加载了一次。</p></li><li><p>执行顺序是子 -&gt; 父</p></li></ul><p>效果如下：</p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-171342721463212.webp" alt="图片"></p><p>12.jpg</p><h4 id="3-导出绑定"><a href="#3-导出绑定" class="headerlink" title="3 导出绑定"></a>3 导出绑定</h4><p><strong>不能修改import导入的属性</strong></p><p><code>a.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">export let num = 1export const addNumber = ()=&gt;&#123;    num++&#125;<br></code></pre></td></tr></table></figure><p><code>main.js</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">import &#123;  num , addNumber &#125; from &#x27;./a&#x27;num = 2<br></code></pre></td></tr></table></figure><p>如果直接修改，那么会报错。如下所示：</p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-171342721463213.webp" alt="图片"><strong>属性绑定</strong></p><p>所以可以在 <code>main.js</code> 中这么修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">import &#123;  num , addNumber &#125; from &#x27;./a&#x27;console.log(num) // num = 1addNumber()console.log(num) // num = 2<br></code></pre></td></tr></table></figure><ul><li>如上属性 num 的导入是绑定的。</li></ul><p>接下来对 import 属性作出总结：</p><ul><li><p>使用 import 被导入的模块运行在严格模式下。</p></li><li><p>使用 import 被导入的变量是只读的，可以理解默认为 const 装饰，无法被赋值</p></li><li><p>使用 import 被导入的变量是与原变量绑定&#x2F;引用的，可以理解为 import 导入的变量无论是否为基本类型都是引用传递。</p></li></ul><h3 id="import-动态引入"><a href="#import-动态引入" class="headerlink" title="import() 动态引入"></a>import() 动态引入</h3><p><code>import()</code> 返回一个 <code>Promise</code> 对象， 返回的 <code>Promise</code> 的 then 成功回调中，可以获取模块的加载成功信息。我们来简单看一下 <code>import()</code> 是如何使用的。</p><p><code>main.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">setTimeout(() =&gt; &#123;    const result  = import(&#x27;./b&#x27;)    result.then(res=&gt;&#123;        console.log(res)    &#125;)&#125;, 0);<br></code></pre></td></tr></table></figure><p><code>b.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">export const name =&#x27;alien&#x27;export default function sayhello()&#123;    console.log(&#x27;hello,world&#x27;)&#125;<br></code></pre></td></tr></table></figure><p>打印如下：</p><p><img src="/2024/04/18/Commonjs%E5%92%8CEsModule%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/640-171342721463214.webp" alt="图片"></p><p>13.jpg</p><p>从打印结果可以看出 <code>import()</code>的基本特性。</p><ul><li><p><code>import()</code> 可以动态使用，加载模块。</p></li><li><p><code>import()</code> 返回一个 <code>Promise</code> ，成功回调 then 中可以获取模块对应的信息。<code>name</code> 对应 name 属性， <code>default</code> 代表 <code>export default</code> 。<code>__esModule</code> 为 es module 的标识。</p></li></ul><h4 id="import-可以做一些什么"><a href="#import-可以做一些什么" class="headerlink" title="import() 可以做一些什么"></a>import() 可以做一些什么</h4><p><strong>动态加载</strong></p><ul><li>首先 <code>import()</code> 动态加载一些内容，可以放在条件语句或者函数执行上下文中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">if(isRequire)&#123;    const result  = import(&#x27;./b&#x27;)&#125;<br></code></pre></td></tr></table></figure><p><strong>懒加载</strong></p><ul><li><code>import()</code> 可以实现懒加载，举个例子 vue 中的路由懒加载；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">[   &#123;        path: &#x27;home&#x27;,        name: &#x27;首页&#x27;,        component: ()=&gt; import(&#x27;./home&#x27;) ,   &#125;,]<br></code></pre></td></tr></table></figure><p><strong>React中动态加载</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">const LazyComponent =  React.lazy(()=&gt;import(&#x27;./text&#x27;))class index extends React.Component&#123;       render()&#123;        return &lt;React.Suspense fallback=&#123; &lt;div className=&quot;icon&quot;&gt;&lt;SyncOutlinespin/&gt;&lt;/div&gt; &#125; &gt;               &lt;LazyComponent /&gt;           &lt;/React.Suspense&gt;    &#125;<br></code></pre></td></tr></table></figure><p><code>React.lazy</code> 和 <code>Suspense</code> 配合一起用，能够有动态加载组件的效果。<code>React.lazy</code> 接受一个函数，这个函数需要动态调用 <code>import()</code> 。</p><p><code>import()</code> 这种加载效果，可以很轻松的实现<strong>代码分割</strong>。避免一次性加载大量 js 文件，造成首次加载白屏时间过长的情况。</p><h3 id="tree-shaking-实现"><a href="#tree-shaking-实现" class="headerlink" title="tree shaking 实现"></a>tree shaking 实现</h3><p>Tree Shaking 在 Webpack 中的实现，是用来尽可能的删除没有被使用过的代码，一些被 import 了但其实没有被使用的代码。比如以下场景：</p><p><code>a.js</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">export let num = 1export const addNumber = ()=&gt;&#123;    num++&#125;export const delNumber = ()=&gt;&#123;    num--&#125;<br></code></pre></td></tr></table></figure><p><code>main.js</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">import &#123;  addNumber &#125; from &#x27;./a&#x27;addNumber()<br></code></pre></td></tr></table></figure><ul><li>如上 <code>a.js</code> 中暴露两个方法，<code>addNumber</code>和 <code>delNumber</code>，但是整个应用中，只用到了 <code>addNumber</code>，那么构建打包的时候，<code>delNumber</code>将作为没有引用的方法，不被打包进来。</li></ul><h2 id="五-Commonjs-和-Es-Module-总结"><a href="#五-Commonjs-和-Es-Module-总结" class="headerlink" title="五 Commonjs 和 Es Module 总结"></a>五 Commonjs 和 Es Module 总结</h2><p>接下来贯穿全文，讲一下 <code>Commonjs</code> 和 <code>Es Module</code> 的特性。</p><h3 id="Commonjs-总结"><a href="#Commonjs-总结" class="headerlink" title="Commonjs 总结"></a>Commonjs 总结</h3><p><code>Commonjs</code> 的特性如下：</p><ul><li><p>CommonJS 模块由 JS 运行时实现。</p></li><li><p>CommonJs 是单个值导出，本质上导出的就是 exports 属性。</p></li><li><p>CommonJS 是可以动态加载的，对每一个加载都存在缓存，可以有效的解决循环引用问题。</p></li><li><p>CommonJS 模块同步加载并执行模块文件。</p></li></ul><h3 id="es-module-总结"><a href="#es-module-总结" class="headerlink" title="es module 总结"></a>es module 总结</h3><p><code>Es module</code> 的特性如下：</p><ul><li><p>ES6 Module 静态的，不能放在块级作用域内，代码发生在编译时。</p></li><li><p>ES6 Module 的值是动态绑定的，可以通过导出方法修改，可以直接访问修改结果。</p></li><li><p>ES6 Module 可以导出多个属性和方法，可以单个导入导出，混合导入导出。</p></li><li><p>ES6 模块提前加载并执行模块文件，</p></li><li><p>ES6 Module 导入模块在严格模式下。</p></li><li><p>ES6 Module 的特性可以很容易实现 Tree Shaking 和 Code Splitting。</p></li></ul><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>本文详细讲解了 Commonjs 和 Es Module ，希望阅读的同学能对前端模块化的实现有更深入的认识。吃透本文，能够轻松应付  Commonjs 和 Es Module 的面试知识点。</p><p>参考：</p><p>[1]. <a href="https://mp.weixin.qq.com/s/dvg8wuJ3p1AAWqTnH3zg6Q">Commonjs 和 Es Module区别</a></p>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack工程化</title>
    <link href="/2024/04/15/webpack%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <url>/2024/04/15/webpack%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h4 id="webpack工程化-面试题"><a href="#webpack工程化-面试题" class="headerlink" title="webpack工程化-面试题"></a>webpack工程化-面试题</h4><h2 id="webpack有哪些常见的loader-你用过哪些loader"><a href="#webpack有哪些常见的loader-你用过哪些loader" class="headerlink" title="webpack有哪些常见的loader? 你用过哪些loader?"></a>webpack有哪些常见的loader? 你用过哪些loader?</h2><ul><li>raw-loader: 加载文件原始内容</li><li>file-loader: 把文件输出到文件夹中，在代码中通过相对url<br>去引用输出的文件夹（包含图片、字体）</li><li>url-loader：和file-loader类似，区别是用户可以设置一个阈值。 大于阈值会交给file-loader 处理，小于阈值则返回base64编码（一般用来处理图片）</li><li>source-map-loader：加载额外的source-map文件，方便断点调试</li><li>image-loader：加载并压缩图片文件</li><li>json-loader：加载json文件</li><li>babel-loader：将es6 装换成es5</li><li>ts-loader：将ts 语音转换成 js</li><li>sass-loader、less-loader：都是转换成css</li><li>css-loader：加载css</li><li>style-loader： 把css注入到js中，通过dom操作加载css</li><li>postcss-loader：扩展css语法，使用下一代css</li><li>eslint-loader、tslint-loader:代码检查。</li><li>vue-loader：加载vue.js单文件组件。</li></ul><h2 id="webpack-有哪些常见的Plugin-你用过哪些Plugin"><a href="#webpack-有哪些常见的Plugin-你用过哪些Plugin" class="headerlink" title="webpack 有哪些常见的Plugin? 你用过哪些Plugin?"></a>webpack 有哪些常见的Plugin? 你用过哪些Plugin?</h2><ul><li>define-plugin：定义环境变量，</li><li>ignore-plugin：忽略部分文件</li><li>html-webpack-plugin：简化html文件创建</li><li>uglifyjs-webpack-plugin：压缩js</li><li>mini-css-extract-plugin：分离样式文件，css提取为单独的文件，支持按需加载</li><li>clean-webpack-plugin：目录清理（用在下次打包之前把上次打包的内容清理掉）</li><li>webpack-bundle-analyzer：可视化webpack输出文件的体积。用于分析当前项目依赖文件的体积大小。</li><li>speed-measure-webpack-plugin：分析每个loader 和 plugin 执行耗时</li></ul><h2 id="说说Loader-和Plugin-的区别"><a href="#说说Loader-和Plugin-的区别" class="headerlink" title="说说Loader 和Plugin 的区别"></a>说说Loader 和Plugin 的区别</h2><h6 id="作用上"><a href="#作用上" class="headerlink" title="作用上"></a>作用上</h6><ul><li>loader 本质是一个函数，对接收到的内容进行转换，返回转换后的结果，webpack只认识js，所以loader就相当于翻译官。对其他类型资源进行转译和预处理。</li><li>plugin：是插件，它基于事件流框架 Tabable，可以扩展webpack功能，在webpack运行的生命周期中会<strong>广播很多事件</strong>。plugin可以监听这些事件，在<strong>适合的时机</strong>通过webpackapi 改变输出的结果。</li></ul><h6 id="结构上"><a href="#结构上" class="headerlink" title="结构上"></a>结构上</h6><ul><li>loader ：在module.rules 中进行配置，类型是数组，每项都是对象，对象包含（test 文件类型，loader 对应的模块加载器，option 对应的参数）</li><li>plugin：每个plugin都需要单独配置，类型是数组，每项plugin是一个plugin实例，参数通过构造函数传入。</li></ul><h2 id="webpack-构建流程简单说一下"><a href="#webpack-构建流程简单说一下" class="headerlink" title="webpack 构建流程简单说一下"></a>webpack 构建流程简单说一下</h2><p>它的运行流程是一个串行的过程。<br>1、初始化参数：从<a href="">配置文件</a>和shell语句中读取并且合并参数，得到最终的参数。<br>2、开始编译：初始化Compiler 对象，加载所有的配置插件。执行对象run方法，开始编译。<br>3、确定入口：根据配置的entry找到所有入口<br>4、翻译模块：调用所有的loader 对模块进行编译，找出模块依赖的模块，再<strong>递归</strong>本步骤直到所有入口依赖的文件都经过处理。<br>5、完成模块编译：经过loader翻译完所有模块后的最终内容以及它们之间的依赖关系。<br>6、输出资源：根据入口以及它们依赖关系组装成一个个包含多个模块的<strong>chunk</strong>，再把每个<strong>chunk 转换成单独的文件</strong>加入到输出列表中。（这里可以修改输出内容，并且是修改的最后一个机会）<br>7、输出完成：根据配置确定输出的路径和文件名，把文件内容写到文件中，</p><blockquote><p>在上面流程中，webpack 会在特定的时间点广播特定事件，插件在监听到事件后调用webpack 提供的API 改变输出结果</p></blockquote><h2 id="使用webpack开发时，使用过哪些可以提高效率的插件？"><a href="#使用webpack开发时，使用过哪些可以提高效率的插件？" class="headerlink" title="使用webpack开发时，使用过哪些可以提高效率的插件？"></a>使用webpack开发时，使用过哪些可以提高效率的插件？</h2><ul><li>webpack-dashboard：更友好的展示的展示相关包信息。</li><li>webpack-merge：提取公共配置，可以将多个配置文件合并，减少代码重复。</li><li>speed-measure-webpack-plugin：分析 loader 和 plugin 的耗时，从而分析构建过程中的性能瓶颈。</li><li>size-plugin：监控资源体积变化，尽早发现问题。</li><li>HotModuleReplacementPlugin：模块热替换。</li></ul><h2 id="如何优化webpack-的构建速度？"><a href="#如何优化webpack-的构建速度？" class="headerlink" title="如何优化webpack 的构建速度？"></a>如何优化webpack 的构建速度？</h2><ol><li>使用高版本webpack 和 node.js</li><li>多进程 &#x2F; 多实例构建 thread-loader</li><li>压缩代码 、多进程并行压缩‘</li></ol><blockquote><p>1）webpack-paralle-uglify-plugin ：可以并行运行 UglifyJS 插件，从而更加充分、合理的使用 CPU<br>资源，从而大大减少构建时间 2）terser-webpack-plugin ：它使用 Terser 库来执行压缩，Terser<br>是一个用于压缩 JavaScript 代码的工具，可以对代码进行简单的混淆，以及删除未使用的代码和注释等优化。 3）<br>mini-css-extract-plugin ： 可以避免将 CSS 代码打包到 JavaScript 文件中，减少 JavaScript<br>的体积，同时也可以使得 CSS 文件可以被浏览器缓存，提高页面加载速度。</p></blockquote><ol start="4"><li>图片压缩 （imagemin、image-webpack-plugin）</li><li>缩小打包作用域<br>1)、通过exclude &#x2F; include 来确定loader 规则范围。<br>2)、设置resolve.extensions.<br>3)、resolve.modules</li><li>提取页面公共的资源<br>1)、基础包分离<br>2)、使用html-webpack-externals-plugin 基础包通过cdn引入，不打入bundle 中。<br>3)、使用splitchunksplugin 将代码拆分成多个块，以便在不同的环境中按需加载。</li><li>充分利用缓存提升二次构建速度。<br>1)、使用 babel-loader 开启缓存<br>2)、terser-webpack-plugin 开启缓存<br>3)、cache-loader 或者 hard-source-webpack-plugin</li><li>tree shaking (没有用过的模块代码进行标记，从最终bundle 中去掉)</li></ol><h2 id="文件指纹是什么？怎么用？"><a href="#文件指纹是什么？怎么用？" class="headerlink" title="文件指纹是什么？怎么用？"></a>文件指纹是什么？怎么用？</h2><p>文件指纹：打包后输出的文件名后缀。</p><ul><li>hash：和整个项目构建相关的，只有项目文件改变、项目的hash值就会改变。</li><li>chunkHash：和webpack打包的chunk 相关，不同的entry产生不同的chunkHash，</li><li>contentHash：根据文件内容定义hash，文件内容不变contentHash就不会变。</li></ul><h5 id="js的文件指纹设置。"><a href="#js的文件指纹设置。" class="headerlink" title="js的文件指纹设置。"></a>js的文件指纹设置。</h5><p>主要设置output 的 fllename 使用 chunkhash.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">entry</span>: &#123;<span class="hljs-attr">spp</span>: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>, <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;./src/search.js&#x27;</span>&#125;,<br><span class="hljs-attr">output</span>: &#123;<span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name][chunkhash:8].js&#x27;</span>,<span class="hljs-attr">path</span>:_dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>&#125;<br><span class="hljs-comment">// chunkhash:8 是设置对应的长度</span><br>&#125;<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><h5 id="css-文件指纹设置"><a href="#css-文件指纹设置" class="headerlink" title="css 文件指纹设置"></a>css 文件指纹设置</h5><p>设置MiniCssExtractPlugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">entry</span>: &#123;<span class="hljs-attr">spp</span>: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>, <span class="hljs-attr">search</span>: <span class="hljs-string">&#x27;./src/search.js&#x27;</span>&#125;,<br><span class="hljs-attr">output</span>: &#123;<span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name][chunkhash:8].js&#x27;</span>,<span class="hljs-attr">path</span>:_dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>&#125;,<br><span class="hljs-attr">plugin</span>: [<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">MinCssExtractPlugin</span>(&#123; <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;[name][contenthash:8].css&#x27;</span>&#125;),<br>]<br>&#125;<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><h5 id="图片相关文件指纹设置"><a href="#图片相关文件指纹设置" class="headerlink" title="图片相关文件指纹设置"></a>图片相关文件指纹设置</h5><p>设置 file-loader 中的name</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    <span class="hljs-attr">output</span>: &#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>      <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>    &#125;, <br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|svg|jpg|gif)$/</span>,<br>                <span class="hljs-attr">use</span>: [<br>&#123;<br>  <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>  <span class="hljs-attr">option</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;img/[name][hash:8].[ext]&#x27;</span>&#125;,<br>&#125;<br>],<br>&#125;<br>]<br>&#125;<br>&#125;<br><span class="hljs-number">123456789101112131415161718192021</span><br></code></pre></td></tr></table></figure><h2 id="是否写过loader？简单描写一下编写loader-的思路？"><a href="#是否写过loader？简单描写一下编写loader-的思路？" class="headerlink" title="是否写过loader？简单描写一下编写loader 的思路？"></a>是否写过loader？简单描写一下编写loader 的思路？</h2><ul><li>loader是支持链式调用的，所有在开发中需要严格遵守单一职责。每个loader负责自己所需要负责的事情。</li><li>loader是运行在nodejs中的，可以调用nodejs api 或者安装第三方模块调用。 传给loader 的原内容是 utf-8</li><li>编码的字符串 尽可能异步化loader ，如果计算量小的化同步也可以</li><li>loader 是无状态的，不应该在loader 中保留状态</li><li>开发loader 时可以使用 loader-utils schema-utils 工具 还可以（通过npm link 和<br>resolveloader 这两种方式）加载本地的loader 方法</li></ul><h2 id="是否写过Plugin？简单描写一下编写Plugin的思路？"><a href="#是否写过Plugin？简单描写一下编写Plugin的思路？" class="headerlink" title="是否写过Plugin？简单描写一下编写Plugin的思路？"></a>是否写过Plugin？简单描写一下编写Plugin的思路？</h2><ul><li>webpack运行生命周期中会广播出很多事件，让plugin 监听事件，特定阶段钩入想要添加的自定义插件内容</li><li>webpack通过tapable 事件流机制保证插件有序性，使系统的扩张性很好</li></ul><p>compiler 暴露整个生命周期相关钩子<br>compliation 暴雷与模块和依赖有关的颗粒度更小的事件钩子<br>plugin 需要再原型上绑定apply方法，才能访问compiler 实例。<br>插件接收 compiler 、compliation 都是同一个引用。<br>找到合适的事件点完成想要执行的内容，</p><h2 id="说说Babel-原理"><a href="#说说Babel-原理" class="headerlink" title="说说Babel 原理"></a>说说Babel 原理</h2><p>在 webpack 中，Babel 主要用于将 ECMAScript 2015+版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其它环境中。Babel 的转化过程如下：</p><ol><li>Parse：使用 babylon 将原始代码转换为抽象语法树。</li><li>Transform：通过 babel-traverse 对前面的抽象语法树进行遍历修改，并获得新的抽象语法树。</li><li>Generator：使用 babel-generator 将抽象语法树转换为代码。</li></ol><p>这三个操作通过 babel-core 合成一个对外的 API 供外界使用。</p><h2 id="source-map-是什么？生产环境怎么用？"><a href="#source-map-是什么？生产环境怎么用？" class="headerlink" title="source map 是什么？生产环境怎么用？"></a>source map 是什么？生产环境怎么用？</h2><p>Source Map 用于将编译、打包、压缩后的代码映射回源代码。</p><p>在生产环境中使用 Source Map 有以下几个步骤：</p><ol><li>在构建过程中生成 Source Map：确保你的构建工具（如 webpack）配置为生成 Source Map。</li><li>部署包含 Source Map 的构建产物：将生成的 Source Map 与构建后的代码一起部署到生产环境。</li><li>在开发工具中启用 Source Map：这样可以在浏览器中查看原始源代码，并在调试时将错误和堆栈跟踪映射回原始代码。</li></ol><p>使用 Source Map 的好处包括：</p><ol><li>更好的调试体验：可以在生产环境中查看和调试原始代码。</li><li>提高开发效率：更容易找到和解决问题。</li></ol><p>然而，需要注意的是，使用 Source Map 会增加构建产物的大小，可能会对性能产生一定影响。因此，在生产环境中应谨慎使用，并在必要时进行优化。</p><h2 id="文件监听原理"><a href="#文件监听原理" class="headerlink" title="文件监听原理"></a>文件监听原理</h2><p>Webpack 文件监听的原理是通过<strong>轮询</strong>判断文件的最后编辑时间是否发生变化。Webpack 首先存储文件的修改时间，下次再有修改时会与上次修改时间进行比对。如果发现不一致，Webpack 不会立即告诉监听者，而是将文件修改缓存起来，等待一段时间。在等待期间，如果有其他文件发生变化，Webpack 会将变化列表一起构建，并生成到 bundle 文件夹。</p><p>文件监听的目的是在发现文件发生变化时，自动重新构建出新的输出文件。开启监听模式有两种方式，在启动 Webpack 命令时带上 –watch 参数，或在配置 webpack.config.js 中设置 watch: true。构建完成后，输出的文件会被放入磁盘中。</p><h2 id="webpack-热更新原理"><a href="#webpack-热更新原理" class="headerlink" title="webpack 热更新原理"></a>webpack 热更新原理</h2><p>Webpack 的热更新（Hot Module Replacement，简称 HMR）是一种在开发时提供实时更新的功能，它使得在修改代码后，不需要完全刷新页面就能立即看到更新的效果。HMR 的原理涉及以下几个主要步骤：</p><ol><li><p>启动时建立 WebSocket 连接：在项目启动时，Webpack 会创建与开发服务器的 WebSocket 连接，用于在构建完成后接收更新的模块。</p></li><li><p>构建编译阶段：Webpack 在编译时会在每个模块中注入 HMR 运行时代码。该代码会监听源代码的变化，并通知 HMR runtime 进行处理。</p></li><li><p>文件监控：Webpack 会监控所有入口文件及其依赖的文件，一旦检测到文件发生变化，会触发重新编译。</p></li><li><p>构建完成：当编译完成后，Webpack 会将编译结果发送给开发服务器，并通过 WebSocket 通知客户端有新的资源可用。</p></li></ol><h2 id="webpack-事件机制了解吗？"><a href="#webpack-事件机制了解吗？" class="headerlink" title="webpack 事件机制了解吗？"></a>webpack 事件机制了解吗？</h2><blockquote><p>常见事件</p><ul><li>before-run：开始执行构建之前触发，可以用于清理上一次构建的临时文件或状态</li><li>run：开始执行构建触发</li><li>before-compile：开始编译代码前触发，可以用于添加一些额外的编辑配置或者预处理代码</li><li>compile：开始编译，可用于监听编译过程或编译处理错误</li><li>this-compilation：创建新的 Compilation 对象触发，Compilation 对象代表当前编辑过程中的所有状态和信息。</li><li>compilataion：编辑代码期间触发，可用于监听编译过程或编译处理错误</li><li>emit：输出文件之前触发，修改输出文件或者生成一些附件文件。</li><li>after-emit：输出文件后触发，用于清理中间文件</li><li>done：构建完成时触发，用于生成构建报告。</li></ul></blockquote><p>事件机制<br>Webpack采用事件驱动的方式打包web应用，其事件机制主要依靠一个很小的<strong>核心库tapable来实现</strong>。封装了事件订阅发布机制。compile、compilataion 都是tapable类的实例对象，</p><h2 id="webpack5-相比于-webpack4-有哪些提升？"><a href="#webpack5-相比于-webpack4-有哪些提升？" class="headerlink" title="webpack5 相比于 webpack4 有哪些提升？"></a>webpack5 相比于 webpack4 有哪些提升？</h2><ul><li>更快的构建速度，尤其是开发模式下构建速度明显的提升</li><li>Tree Shaking：优化算法。更准确哪些代码无用，更好的优化构建输出的文件大小</li><li>内置的持久化缓存：可以缓存每个模块编译结果，加速后续构建，</li><li>支持 WebAssmbly</li><li>模块联班：Module federation 解决模块共享、远程加载。为微前端架构提供支持。</li></ul><h2 id="对模块联班的理解"><a href="#对模块联班的理解" class="headerlink" title="对模块联班的理解"></a>对模块联班的理解</h2><p>模块联邦（Module Federation）是 Webpack 5 推出的一个新特性。它是一种模块共用机制，允许本地调用远程的模块。通过模块联邦可以解决微前端依赖问题，对比 npm 库具有实时性的优势。</p><h2 id="Webpack-中有哪些核心概念？"><a href="#Webpack-中有哪些核心概念？" class="headerlink" title="Webpack 中有哪些核心概念？"></a>Webpack 中有哪些核心概念？</h2><p>Webpack 中有以下几个核心概念：</p><ol><li>模块：Webpack 会将各种资源（如 JavaScript、CSS、图像等）视为模块。</li><li>入口：指定 Webpack 开始构建的起点。</li><li>输出：定义了最终生成的文件。</li><li>加载器：用于处理特定类型的文件。</li><li>插件：扩展 Webpack 的功能。</li><li>依赖关系：模块之间的依赖关系。</li><li>模块解析：确定如何查找和加载模块。</li><li>代码分割：将代码分割成多个块，按需加载。</li><li>优化：例如压缩、合并等，提高性能。</li><li>热更新：在运行时自动更新变更的模块。</li></ol><h2 id="webpack-的mode是什么？"><a href="#webpack-的mode是什么？" class="headerlink" title="webpack 的mode是什么？"></a>webpack 的mode是什么？</h2><p>Webpack 的 mode 提供了 mode 配置选项，告知 Webpack 使用相应模式的内置优化。mode 的值可以是 <strong>development、production 或 none</strong>，分别代表开发模式、生产模式和无预设模式（需要从头开始配置）。如果 mode 没有被设置，系统会默认使用 production 模式。</p><ol><li>development（开发模式）：提供了一些有助于开发和调试的特性，更详细的错误信息和警告。实时重新加载。 未压缩的代码以提高调试效率。</li><li>production（生产模式）：用于准备上线的构建，强调优化和性能：代码压缩和混淆。 资源优化。</li><li>none (无预设模式) 关闭任何默认优化选项，只执行基本打包功能，不做任何额外处理。</li></ol><h2 id="什么是代码分割（code-Splitting），如何在webpack中实现？"><a href="#什么是代码分割（code-Splitting），如何在webpack中实现？" class="headerlink" title="什么是代码分割（code Splitting），如何在webpack中实现？"></a>什么是代码分割（code Splitting），如何在webpack中实现？</h2><p>代码分割是将一个应用程序的代码拆分成多个独立的块，以便可以按需加载。可以减少初始加载时间提高页面性能，在 Webpack 中配置实现代码分割，有以下多种方式：<br>1、入口起点配置：配置多个入口起点，不同部分打包成独立的代码块。<br>2、动态导入 （Dynamic import）:可以将模块作为单独的代码块按需加载，这样模块需要时才会下载执行，<br>3、使用 SplitChunksPlugin 插件来自动分割代码。自动拆分公共模块，并创建独立代码块，避免重启加载，提高缓存利用率。<br>4、使用 CommonsChunkPlugin 插件来提取公共模块。</p>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css浮动</title>
    <link href="/2023/10/17/css%E6%B5%AE%E5%8A%A8/"/>
    <url>/2023/10/17/css%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="浮动与清除浮动"><a href="#浮动与清除浮动" class="headerlink" title="浮动与清除浮动"></a>浮动与清除浮动</h1><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="float-属性的取值"><a href="#float-属性的取值" class="headerlink" title="float 属性的取值"></a>float 属性的取值</h3><ul><li>left：元素向左浮动</li><li>right：元素向右浮动</li><li>none：默认值，元素不会浮动，并会显示在其文本中出现的位置</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对其进行环绕；</li><li>不管一个元素是行内元素还是块级元素，只要被设置了浮动，那浮动元素就会形成一个块级框，可以设置它的宽度和高度，因此浮动元素常常用于制作横向配列的菜单，可以设置大小并且横向排列。</li></ul><h3 id="浮动元素的展示在不同情况下会有不同的规则"><a href="#浮动元素的展示在不同情况下会有不同的规则" class="headerlink" title="浮动元素的展示在不同情况下会有不同的规则"></a>浮动元素的展示在不同情况下会有不同的规则</h3><ul><li>浮动元素在浮动的时候，其 margin 不会超过包含块的 padding</li><li>如果两个元素一个向左浮动，一个向右浮动，左浮动元素的 margin-right 不会和右元素的 margin-left 相邻</li><li>如果有多个浮动元素，浮动元素会按顺序排下来而不会发生重叠</li><li>如果有多个浮动元素，后面的元素高度不会超过前面的元素，并且不会超过包含块</li><li>如果有非浮动元素和浮动元素同时存在，并且非浮动元素在前，则浮动元素不会高于非浮动元素</li><li>浮动元素会尽可能地向顶端对齐、向左或向右对齐</li></ul><h3 id="重叠问题"><a href="#重叠问题" class="headerlink" title="重叠问题"></a>重叠问题</h3><ul><li>行内元素与浮动元素发生重叠，其边框、背景和内容都会显示在浮动元素之上</li><li>块级元素与浮动元素发生重叠时，边框和背景会显示在浮动元素之下，内容会显示在浮动元素之下</li></ul><h3 id="clear-属性"><a href="#clear-属性" class="headerlink" title="clear 属性"></a>clear 属性</h3><blockquote><p>  确保当前元素的左右两侧不会有浮动元素，clear 只对元素本身的布局起作用</p></blockquote><ul><li>left</li><li>right</li><li>both</li></ul><h2 id="父元素高度塌陷问题"><a href="#父元素高度塌陷问题" class="headerlink" title="父元素高度塌陷问题"></a>父元素高度塌陷问题</h2><blockquote><p>  为什么需要清除浮动</p></blockquote><p>一个块级元素如果没有设置高度，其高度是由子元素撑开的。如果对子元素设置了浮动，那么子元素就会脱离文档流，也就是说父元素没有内容可以撑开其高度，这样父级元素的高度就会被忽略，这就是所谓的高度塌陷。</p><h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ol><li><p>给父元素定义高度</p><ul><li>优点：操作简单</li><li>缺点：高度定死</li></ul></li><li><p>添加一个空元素 <code>&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; (.clear &#123; clear: both &#125;)</code></p><ul><li>优点：浏览器支持好</li><li>缺点：凭空多出很多无用空节点</li></ul></li><li><p>让父元素也一起浮动</p><ul><li>缺点：无法解决实际问题</li></ul></li><li><p>父元素设置为 <code>display: table</code></p><ul><li>缺点：会产生新的问题</li></ul></li><li><p>父元素设置 <code>overflow: hidden auto</code></p><ul><li>缺点：无法显示溢出的元素</li></ul></li><li><p>父元素伪元素设置清除浮动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>  ...<br>&#125;<br><br><span class="hljs-selector-class">.father</span>:: after &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27; &#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">clear</span>: both;<br>  <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>float</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex 学习记录</title>
    <link href="/2023/10/12/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/10/12/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>今天在做项目的时候遇到一个关于布局的问题, 就是 <strong>flex: 1;</strong> 我一直以为 flex: 1; 代表的是 <strong>flex: auto;</strong> 后来发现结果并不是这样, 所以写一篇博客来讲解一下 flex: 1; 代表什么</p><h2 id="代码第一版"><a href="#代码第一版" class="headerlink" title="代码第一版"></a>代码第一版</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span>我是一个div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span>我是一个很多字div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span>我是一个更多字而且第三个div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.div</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br><span class="language-css">  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/10/12/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-8cc589398d0576b41e365af19b9e9325_r.jpg"></p><p>利用 <strong>flex: 1; 确实实现了三个不同内容的 div 平分空间, 所以按我以前的想法来说:</strong></p><blockquote><p><strong>flex: 1; &#x3D;&#x3D;&#x3D; flex: 1 1 auto;</strong></p></blockquote><p>这是完整写法, 详见**<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex">mdn</a>**, 它还有另外两种完整写法, 分别是 <strong>initial (0 1 auto)</strong> 和 <strong>none (0 0 auto)</strong></p><ul><li>第一个参数表示: <strong>flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</strong></li><li>第二个参数表示: <strong>flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</strong></li><li>第三个参数表示: <strong>flex-basis</strong> <strong>给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小</strong></li></ul><h2 id="代码第二版"><a href="#代码第二版" class="headerlink" title="代码第二版"></a>代码第二版</h2><p>上面证实了我以前的想法, flex:1; 就是代表均匀分配元素, 但是我们来改成完整写法看看</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 其他代码没有变化, 沿用上面的 */</span><br><br><span class="hljs-selector-class">.div</span>&#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span> auto; <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/10/12/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-c52fab6fae7537b9223b28d786bb4d3c_r.jpg"></p><p>加入原来以为正确的完整代码后可以看到三个元素没有<strong>均分</strong>, 所以可以推出:</p><blockquote><p><strong>flex: 1; !&#x3D;&#x3D; flex: 1 1 auto;</strong></p></blockquote><p><strong>走到这我就一头雾水, 为什么和我以前想的完全不同, 于是我就去参照了 <a href="https://www.w3.org/TR/css-flexbox-1/#flex-common">w3c</a></strong> <strong>对于 flex 的解释, 官方明确指, flex 最后一个参数为 0, 见下图</strong></p><p><img src="/2023/10/12/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-c1a91d2970defbd29c6fd9e897f9414c_r.jpg"></p><p><strong>所以:</strong></p><ul><li><strong>flex: 1; &#x3D;&#x3D;&#x3D; flex: 1 1 0;</strong></li></ul><p>但是在 chrome 浏览器上设置 flex: 1 1 0; 时, 它会自动加一个单位 px</p><p><img src="/2023/10/12/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-679d29029cd5ac3996ac7f278e6d411d_r.jpg"></p><p>而设置 flex: 1; 时, 它会自动加一个 %, 看来他们解析到浏览器的时候必须带一个单位</p><p><img src="/2023/10/12/flex%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/v2-533796bc14adcb110e2bc96e60330b55_r.jpg"></p><p>于是我就又做了几个实验, 改了一下 flex-basis 的参数, <strong>得出以下结论</strong></p><ul><li><strong>flex: 1; &#x3D;&#x3D;&#x3D; flex: 1 1 任意数字+任意长度单位;</strong></li></ul><p><strong>可以看出最重要的一点在 第三个参数 flex-basis 上, 我们再来回顾以下 这个属性的作用</strong></p><blockquote><p><strong>flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小</strong></p></blockquote><p>auto 为表示项目本身的大小, <strong>如果设置为 auto, 那么这三个盒子就会按照自己内容的多少来等比例的放大和缩小</strong>, 所以出现了上图中三个盒子不一样大的情况</p><p>那我们如果<strong>随便设置一个其他带有长度单位的数字</strong>呢, 那么他就不会按项目本身来计算, 所以它不关心内容, 只是把空间等比收缩和放大</p><p>现在你知道 flex: 1; 为什么能平分元素了吧, CSS 是一门很难学的语言, 虽然我经过不断试验得出结果, 但是它还有好多莫名其妙的问题去等你发现. 比如 <strong>margin: auto 为什么会实现居中, overflow: hidden 为何能实现 BFC</strong></p><p><strong>你可以遵从官方标准, 也可以和我一样去实验性的看待 flex: 1;</strong></p><p><strong>不过我建议你别深究这些问题, 因为所见即所得, 它这样能实现效果就可以了, CSS 学习是没必要刨根问底的, 会用就是最好的证明, 以上仅为个人见解, 如有疑问请给我留言或私信</strong></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css3</tag>
      
      <tag>flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github访问问题解决记录</title>
    <link href="/2023/07/27/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/07/27/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="解决-Github-port-443-Timed-out"><a href="#解决-Github-port-443-Timed-out" class="headerlink" title="解决 Github port 443 : Timed out"></a>解决 Github port 443 : Timed out</h1><p>Failed to connect to <a href="http://github.com/">github.com</a> port 443 : Timed out</p><h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>如下图所示，无法 git clone 来自 Github 上的仓库，报端口 443 错误</p><p><img src="/2023/07/27/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/v2-3b264466dfeec3e70ff0534c35da18c2_r.jpg"></p><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><p>Git 所设端口与系统代理不一致，需重新设置</p><h2 id="三、解决方法"><a href="#三、解决方法" class="headerlink" title="三、解决方法"></a>三、解决方法</h2><h3 id="3-1、打开代理页面"><a href="#3-1、打开代理页面" class="headerlink" title="3-1、打开代理页面"></a>3-1、打开代理页面</h3><p>打开 设置 –&gt; 网络与Internet –&gt; 查找代理</p><p><img src="/2023/07/27/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/v2-baceb7a931e8f13ff5b0956a68955639_b.gif"></p><p>记录下当前系统代理的 IP 地址和端口号</p><p>如上图所示，地址与端口号为：127.0.0.1:7890</p><p>可以尝试直接关闭设置内的系统代理，如果无效再修改git网络设置</p><h3 id="3-2、修改-Git-的网络设置"><a href="#3-2、修改-Git-的网络设置" class="headerlink" title="3-2、修改 Git 的网络设置"></a>3-2、修改 Git 的网络设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意修改成自己的IP和端口号</span><br>git config --global http.proxy http://127.0.0.1:7890 <br>git config --global https.proxy http://127.0.0.1:7890<br></code></pre></td></tr></table></figure><p><img src="/2023/07/27/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/v2-32f6f2e6e7ea50f9de6f9aa35bd56dcd_r.jpg"></p><h2 id="四、完结撒花"><a href="#四、完结撒花" class="headerlink" title="四、完结撒花"></a>四、完结撒花</h2><p>可以重新 clone 尝试了（其实主要解决的是为啥搭建了梯子依旧不好使的问题，哈哈哈）</p><h2 id="五、后记"><a href="#五、后记" class="headerlink" title="五、后记"></a>五、后记</h2><p>当我们访问GitHub的时候一般都会使用梯子，所以往上推代码的时候也是需要梯子，没有梯子推送成功概率很低，一般都会报错超时，所以设置梯子提高访问成功率；</p><p>取消代理是因为，访问 Gitee 或其它是不需要梯子，所以要取消代理；或者后悔设置代理了，也可以利用此取消</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 取消代理</span><br>git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br><br><span class="hljs-comment"># 查看代理</span><br>git config --global --get http.proxy<br>git config --global --get https.proxy<br></code></pre></td></tr></table></figure><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/636418854">解决 Github port 443 : Timed out - 知乎</a></p><h1 id="OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="OpenSSL SSL_read: Connection was reset, errno 10054"></a>OpenSSL SSL_read: Connection was reset, errno 10054</h1><p>问题场景：之前关联的github库没办法上传（push）了，提示本地库不存在。于是做了</p><p>git init &#x2F;&#x2F;初始化资源库</p><p><strong>git remote</strong>-v origin https:<strong>&#x2F;&#x2F;</strong><a href="http://github.com/">http://github.com/</a>我的库 &#x2F;&#x2F;将本地库与远程库做关联，</p><p>git pull 先将线上的资源拉取下来。</p><p>问题出在了git pull的时候，提示错误</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">fatal: unable to access &#x27;http://github.com/我的库/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054<br></code></pre></td></tr></table></figure><p>报错原因：</p><p>字面意思：服务器的<a href="https://so.csdn.net/so/search?q=SSL&spm=1001.2101.3001.7020">SSL</a>证书灭有经过第三方机构的签署。</p><p>网上信息也有的说可能是网络不稳定，连接超时导致。</p><p>解决办法：</p><p>1.修改设置，解除SSL验证。打开 <a href="https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E8%A1%8C&spm=1001.2101.3001.7020">命令行</a>工具， 输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global http.sslVerify &quot;false&quot;<br>git config --global https.sslVerify &quot;false&quot;<br></code></pre></td></tr></table></figure><p>2、打开本地仓库的.git文件夹下的config文件</p><p>可以看到如下配置：</p><p><img src="/2023/07/27/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/v2-a2dca06821dc763f84f6dad814011606_r.jpg"></p><p>配置文件</p><p>3、git pull 成功</p><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/492983195">OpenSSL SSL_read: Connection was reset, errno 10054 - 知乎</a></p><h1 id="使用-git-进行-push-时几乎无法连接"><a href="#使用-git-进行-push-时几乎无法连接" class="headerlink" title="使用 git 进行 push 时几乎无法连接"></a>使用 git 进行 push 时几乎无法连接</h1><p><img src="/2023/07/27/Github%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/%E5%9B%BE%E7%89%87_20230727151609-bak.png" alt="图片_20230727151609-bak"></p><p>原文链接：<a href="https://www.v2ex.com/t/819005">使用 git 进行 push 时几乎无法连接 - V2EX</a></p>]]></content>
    
    
    <categories>
      
      <category>日常问题解决记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>git</tag>
      
      <tag>timeout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo结合GitHubPage自定义域名开启Https</title>
    <link href="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/"/>
    <url>/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li>购买阿里云域名</li><li>注册<a href="https://app.netlify.com/">netlify</a>账号</li><li>博客搭建参考：<a href="https://reclusew.github.io/2021/08/12/blog-setup/">将博客部署到GitHubPage</a></li></ol><h1 id="HTTPS设置"><a href="#HTTPS设置" class="headerlink" title="HTTPS设置"></a>HTTPS设置</h1><p>HTTPS 的好处：</p><ul><li>保护用户的隐私信息安全：在 HTTP 网站数据以明文方式传输，客户的隐私极容易被盗取和泄露，而部署 SSL 证书，数据以 HTTPS 加密传输，可以保护通信不被第三方监听和窃取，从而保护用户隐私及安全。还可增加用户信任感和提升企业形象。</li><li>保护网站的安全性和完整性：HTTPS 是安全套接层超文本传输协议，可以保证网站的信息从用户浏览器到服务器之间的传输是高强度加密传输的，是不会被第三方窃取和篡改的，还能避免网站被劫持而插入广告等，防止被钓鱼网站攻击，从而保护网站的安全性和完整性</li><li>防止被钓鱼网站攻击，有效识别网站真实身份：http 网站会被浏览器标记 “不安全”，而安装 https 证书会取消这种 “不安全” 的警告，能增加访客信任度。同时对于安装了 OV SSL 证书或 EV SSL 证书的网站，还能向用户证明网站的真实身份，防止网站被钓鱼网站仿冒。</li></ul><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="设置Github仓库"><a href="#设置Github仓库" class="headerlink" title="设置Github仓库"></a>设置Github仓库</h3><p>进入部署仓库Settings -&gt; Pages -&gt; Custom domain，如图所示，同时开启<code>Enforce HTTPS</code></p><p><img src="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726162422169.png" alt="image-20230726162422169"></p><h3 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>按照图示设置</p><p><img src="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726163106611.png" alt="image-20230726163106611"></p><h3 id="设置完毕"><a href="#设置完毕" class="headerlink" title="设置完毕"></a>设置完毕</h3><p>设置完毕之后显示如图，虽然已经开启开启HTTPS但是浏览器依然显示不安全，故有方法二使用Netlify优化HTTPS</p><p><img src="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726161257464.png" alt="image-20230726161257464"></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="Netlify简介"><a href="#Netlify简介" class="headerlink" title="Netlify简介"></a>Netlify简介</h3><ul><li>可以使用 CLI 上传代码</li><li>支持自定义域名且自定义域名支持一键开启 https（证书来自 Let’s Encrype）</li><li>支持强制让用户通过 https 访问网站（开启后此功能后，http 的访问一律会 301 跳转到 https</li><li>支持自动构建</li><li>支持重定向（Redirects）和重写（Rewrites）功能</li><li>数据通过 HTTP2 协议传输</li><li>提供 webhooks 与 API</li></ul><h3 id="Netlify使用"><a href="#Netlify使用" class="headerlink" title="Netlify使用"></a>Netlify使用</h3><h4 id="1-创建网页-，选择Import-an-existing-project"><a href="#1-创建网页-，选择Import-an-existing-project" class="headerlink" title="1. 创建网页 ，选择Import an existing project"></a>1. 创建网页 ，选择Import an existing project</h4><p><img src="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726163946968.png" alt="image-20230726163946968"></p><h4 id="2-导入项目，选择Deploy-with-GitHub，选择相应的仓库等待构建完成即可"><a href="#2-导入项目，选择Deploy-with-GitHub，选择相应的仓库等待构建完成即可" class="headerlink" title="2. 导入项目，选择Deploy with GitHub，选择相应的仓库等待构建完成即可"></a>2. 导入项目，选择Deploy with GitHub，选择相应的仓库等待构建完成即可</h4><p><img src="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726164239295.png" alt="image-20230726164239295"></p><h4 id="3-设置自定义域名"><a href="#3-设置自定义域名" class="headerlink" title="3. 设置自定义域名"></a>3. 设置自定义域名</h4><p>按图中步骤设置域名即可</p><p><img src="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726164630063.png" alt="image-20230726164630063"></p><h4 id="4-阿里云域名解析设置"><a href="#4-阿里云域名解析设置" class="headerlink" title="4. 阿里云域名解析设置"></a>4. 阿里云域名解析设置</h4><p>此步骤与 <strong>方法一</strong> 中的<strong>设置解析域名</strong>基本一致，记录值替换为 **Netlify **提供的地址即可<img src="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726164837226.png" alt="image-20230726164837226"></p><h4 id="5-开启HTTPS"><a href="#5-开启HTTPS" class="headerlink" title="5. 开启HTTPS"></a>5. 开启HTTPS</h4><p><img src="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726165139140.png" alt="image-20230726165139140"></p><h3 id="设置完毕-1"><a href="#设置完毕-1" class="headerlink" title="设置完毕"></a>设置完毕</h3><p>显示如下，HTTPS已开启</p><p><img src="/2023/07/26/hexo%E5%8D%9A%E5%AE%A2GitHubPage%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%BC%80%E5%90%AFHttps/image-20230726165523754.png" alt="image-20230726165523754"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>推荐方法二，使用Netlify配置</p><br /><br /><p>参考链接：</p><p>[1]. <a href="https://cloud.tencent.com/developer/article/1964351">Hexo博客自定义域名开启HTTPS-腾讯云开发者社区-腾讯云</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHubPages</tag>
      
      <tag>Https</tag>
      
      <tag>自定义域名</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2双端diff算法学习</title>
    <link href="/2023/07/25/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/25/Vue2%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>Vue2 的双端 diff 算法学习。</p><p>篇幅原因，本文并不会介绍虚拟 DOM 树是如何生成的，仅讲解在数据更新时，是如何比较两颗虚拟 DOM 树并更新真实 DOM 的，主要实现 Vue2 源码中的 <code>patchVnode</code>、<code>updateChildren</code> 函数</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="diff-算法作用"><a href="#diff-算法作用" class="headerlink" title="diff 算法作用"></a>diff 算法作用</h2><p>聊 diff 算法前得认识一下它是干嘛的。</p><p>我们知道在网页运行中，我们改变一些数据，它们可能会影响到 DOM 树。如何在页面中展示最新的数据呢，最简单的方式就是整棵树推到重建，当然这样会导致大量的浪费，所以 Vue 使用虚拟 DOM 保存页面中 DOM 树的状态，在数据变化后，构建一棵新的虚拟 DOM 树，找到前后两颗树的不同之处，针对性地更新真实 DOM。</p><p>而如何找到两颗树的不同之处，减少 DOM 元素的销毁与重建，就是 diff 算法的作用</p><h2 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h2><p>虚拟 DOM，又称虚拟节点(vnode)，简单来说就是包含 DOM 元素信息的对象，一般由 <code>h</code> 函数创建，下面这个对象就可以看成是一个虚拟节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-comment">// 标签类型</span><br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 文本内容</span><br>    <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 子节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于这段 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>a<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>b<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>转换成 vnode 是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-comment">// 标签类型</span><br>    <span class="hljs-attr">text</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 文本内容</span><br>    <span class="hljs-attr">children</span>: [ <span class="hljs-comment">// 子节点</span><br>        &#123;<br>            <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;p&#x27;</span>,<br>            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>            <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;p&#x27;</span>,<br>            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>            <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;p&#x27;</span>,<br>            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;c&#x27;</span>,<br>            <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>,<br>        &#125;,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们需要通过虚拟节点去操作真实 DOM，所以 vnode 身上有个 elm 属性指向真实的 DOM 元素。而且在之后的 diff 算法中，还会用到一个 key 来对节点进行唯一标识，所以下文中的 vnode 是这样的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-comment">// 标签类型</span><br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 文本内容</span><br>    <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 子节点</span><br>    <span class="hljs-attr">elm</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 对应的真实DOM</span><br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 唯一标识</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Vue 的虚拟节点还有很多属性，不过与 diff 算法无关，就不列举了</p><blockquote><p>说明一点，虚拟节点的 text 和 children 不会同时有值。在有 children 属性的情况下，text 中的内容会转化为一个文本节点置入 children 数组中</p></blockquote><h2 id="预备函数"><a href="#预备函数" class="headerlink" title="预备函数"></a>预备函数</h2><p>为了使等会的代码实现更简单，我们准备几个函数，功能不难，直接贴代码了</p><p>我们首先需要就是一个将虚拟节点转换为真实 DOM 的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 根据虚拟节点创建真实节点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">vnode</span>) &#123;<br>    <span class="hljs-keyword">const</span> dom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>)<br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">children</span>) &#123;<br>        <span class="hljs-comment">// 包含子节点，递归创建</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; vnode.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">const</span> childDom = <span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">children</span>[i])<br>            dom.<span class="hljs-title function_">appendChild</span>(childDom)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 内部是文字</span><br>        dom.<span class="hljs-property">innerHTML</span> = vnode.<span class="hljs-property">text</span><br>    &#125;<br>    <span class="hljs-comment">// 补充elm属性</span><br>    vnode.<span class="hljs-property">elm</span> = dom<br>    <span class="hljs-keyword">return</span> dom<br>&#125;<br></code></pre></td></tr></table></figure><p>以及三个工具函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断是否未定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isUndef</span>(<span class="hljs-params">v</span>) &#123;<br>    <span class="hljs-keyword">return</span> v === <span class="hljs-literal">undefined</span> || v === <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-comment">// 判断是否已定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isDef</span>(<span class="hljs-params">v</span>) &#123;<br>    <span class="hljs-keyword">return</span> v !== <span class="hljs-literal">undefined</span> &amp;&amp; v !== <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-comment">// 检查是否可复用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkSameVnode</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-property">tag</span> === b.<span class="hljs-property">tag</span> &amp;&amp; a.<span class="hljs-property">key</span> === b.<span class="hljs-property">key</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h1><p>当数据更新后，Vue 创建出一棵新 vnode，然后执行 <code>patchVnode</code> 函数比较新老两个虚拟节点的不同之处，然后根据情况进行处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchVnode</span>(<span class="hljs-params">newVnode, oldVnode</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>首先判断新旧两个虚拟节点是同一对象，如果是的话就不用处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (oldVnode === newVnode) <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>然后将旧节点的 DOM 元素赋给新节点，并获取新旧节点的 children 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> elm = (newVnode.<span class="hljs-property">elm</span> = oldVnode.<span class="hljs-property">elm</span>)<br><span class="hljs-keyword">let</span> oldCh = oldVnode.<span class="hljs-property">children</span><br><span class="hljs-keyword">let</span> newCh = newVnode.<span class="hljs-property">children</span><br></code></pre></td></tr></table></figure><p>这里可以直接赋值是因为调用 patchVnode 的新旧节点它们的 tag 与 key 是一定相同的，在下文会有讲解</p><p>然后根据两个节点内容，决定如何更新 DOM</p><ol><li>新旧两个节点内容都是文本。修改文本即可</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isUndef</span>(newCh)) &#123;<br>    <span class="hljs-keyword">if</span> (newVnode.<span class="hljs-property">text</span> !== oldVnode.<span class="hljs-property">text</span>) &#123;<br>        elm.<span class="hljs-property">innerText</span> = newVnode.<span class="hljs-property">text</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>旧节点有子节点，新节点内容是文本。清空旧节点内容，改为文本</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isUndef</span>(newCh)) &#123;<br>    elm.<span class="hljs-property">innerHTML</span> = newVnode.<span class="hljs-property">text</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>旧节点内容是文本，新节点有子节点。清空旧节点内容，遍历新节点生成子 DOM 元素插入节点中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isDef</span>(newCh)) &#123;<br>    elm.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, n = newCh.<span class="hljs-property">length</span>; i &lt; n; i++)&#123;<br>        elm.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">createElement</span>(newCh[i]))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>新旧节点都有子节点。调用 <code>updateChildren</code> 来处理，该函数在下一章讲解</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isDef</span>(newCh)) &#123;<br>    <span class="hljs-title function_">updateChildren</span>(elm, oldCh, newCh)<br>&#125;<br></code></pre></td></tr></table></figure><p>情况 4 可以与情况 3 的处理一样，清空旧节点，然后遍历生成新 DOM。但是我们要知道，创建 DOM 元素是一件非常耗时的工作，而且新旧子节点在大多时候都是相同的，如果可以复用，将极大优化我们的性能。</p><p>那我们要如何判定一个节点是否可以复用呢？</p><p>这就需要 Vue 的使用者来帮忙了，使用者在节点上定义 key 属性，告诉 Vue 哪些节点可以复用</p><p><strong>只要标签类型与 key 值都相等，就说明当前元素可以被复用</strong></p><p>然而在我们的项目中，一般只有在 v-for 中才设置 key，其他节点都没设置 key</p><p>其实<strong>没有设置 key 的节点，它们的 key 值默认相等</strong></p><p>事实也是如此，我们项目中大部分元素都可以复用，只有 v-for 生成的子元素，它依赖的数组可能发生一些较复杂的变化，所以才需要明确标注 key 值，以帮助 Vue 尽可能地复用节点。</p><blockquote><p>patchVnode 的内容当然不止这些，还有样式、类名、props等数据的对比更换，篇幅原因本文将其省略了。</p></blockquote><h1 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h1><h2 id="为什么采用双端-diff"><a href="#为什么采用双端-diff" class="headerlink" title="为什么采用双端 diff"></a>为什么采用双端 diff</h2><p>好了，Vue 的使用者为每个节点的设置了 key，我们要如何从老节点中找到 key 相等的节点复用元素呢？</p><p>简单的方式就是穷举遍历，对于每个新节点的 key 遍历所有老节点，找到了就移动到首位，没找到就创建添加。</p><p>然而这明显有优化的空间，Vue 实现这部分功能时借鉴了 snabbdom 的双端 diff 算法，因为此算法将我们平时操作数组常见的 4 种情况抽离了出来，涵盖了我们业务中的大多数场景，将 O(n<sup>2</sup>) 的时间复杂度降到了 O(n)</p><p>接下来我们来学习这是如何实现的</p><h2 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h2><p>函数实现较为复杂，我直接把完整的代码放上来，再带领大家一段段解读</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 三个参数为：父DOM元素，旧的子节点数组，新的子节点数组</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span>(<span class="hljs-params">parentElm, oldCh, newCh</span>) &#123;<br>    <span class="hljs-comment">// 旧前索引</span><br>    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 新前索引</span><br>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 旧后索引</span><br>    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 新后索引</span><br>    <span class="hljs-keyword">let</span> newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 四个索引对应节点</span><br>    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]<br>    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx]<br><br>    <span class="hljs-keyword">let</span> keyMap<br><br>    <span class="hljs-comment">// 开始循环</span><br>    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>        <span class="hljs-comment">// 跳过空节点 (和最后一种情况有关)</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldStartVnode)) &#123;<br>            oldStartVnode = oldCh[++oldStartIdx]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldEndVnode)) &#123;<br>            oldEndVnode = oldCh[--oldEndIdx]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">checkSameVnode</span>(oldStartVnode, newStartVnode)) &#123;<br>            <span class="hljs-comment">// 情况1</span><br>            <span class="hljs-comment">// 旧前和新前相等，不需要移动</span><br>            <span class="hljs-title function_">patchVnode</span>(newStartVnode, oldStartVnode)<br>            oldStartVnode = oldCh[++oldStartIdx]<br>            newStartVnode = newCh[++newStartIdx]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">checkSameVnode</span>(oldEndVnode, newEndVnode)) &#123;<br>            <span class="hljs-comment">// 情况2</span><br>            <span class="hljs-comment">// 旧后和新后相等，也不需要移动</span><br>            <span class="hljs-title function_">patchVnode</span>(newEndVnode, oldEndVnode)<br>            oldEndVnode = oldCh[--oldEndIdx]<br>            newEndVnode = newCh[--newEndIdx]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">checkSameVnode</span>(oldStartVnode, newEndVnode)) &#123;<br>            <span class="hljs-comment">// 情况3</span><br>            <span class="hljs-comment">// 旧前和新后相等</span><br>            <span class="hljs-comment">// 旧序列的第一个节点，变成了新序列的最后一个节点</span><br>            <span class="hljs-comment">// 需要将这个节点移动到旧序列最后一个节点的后面</span><br>            <span class="hljs-comment">// 也就是最后一个节点的下一个节点的前面</span><br>            parentElm.<span class="hljs-title function_">insertBefore</span>(oldStartVnode.<span class="hljs-property">elm</span>, oldEndVnode.<span class="hljs-property">elm</span>.<span class="hljs-property">nextSibling</span>)<br>            <span class="hljs-title function_">patchVnode</span>(newEndVnode, oldStartVnode)<br>            oldStartVnode = oldCh[++oldStartIdx]<br>            newEndVnode = newCh[--newEndIdx]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">checkSameVnode</span>(oldEndVnode, newStartVnode)) &#123;<br>            <span class="hljs-comment">// 情况4</span><br>            <span class="hljs-comment">// 旧后和新前相等</span><br>            <span class="hljs-comment">// 旧序列的最后一个节点，变成了新序列的第一个节点</span><br>            <span class="hljs-comment">// 需要将这个节点移动到旧序列第一个节点的前面</span><br>            parentElm.<span class="hljs-title function_">insertBefore</span>(oldEndVnode.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)<br>            <span class="hljs-title function_">patchVnode</span>(newStartVnode, oldEndVnode)<br>            oldEndVnode = oldCh[--oldEndIdx]<br>            newStartVnode = newCh[++newStartIdx]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 以上四种情况都不符合</span><br>            <span class="hljs-comment">// 制作旧节点key的映射对象</span><br>            <span class="hljs-comment">// 键为 key，值为 索引</span><br>            <span class="hljs-keyword">if</span> (!keyMap) &#123;<br>                keyMap = &#123;&#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;<br>                    keyMap[oldCh[i].<span class="hljs-property">key</span>] = i<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 寻找当前新节点在keyMap中映射的位置序号</span><br>            <span class="hljs-keyword">const</span> idxInOld = keyMap[newStartVnode.<span class="hljs-property">key</span>]<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(idxInOld)) &#123;<br>                <span class="hljs-comment">// 没有找到，表示他是全新的项</span><br>                <span class="hljs-comment">// 转化为DOM节点，加入旧序列第一个节点的前面</span><br>                parentElm.<span class="hljs-title function_">insertBefore</span>(<span class="hljs-title function_">createElement</span>(newStartVnode), oldStartVnode.<span class="hljs-property">elm</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 不是全新的项，需要移动</span><br>                <span class="hljs-keyword">const</span> oldVnode = oldCh[idxInOld]<br>                <span class="hljs-comment">// 移动到旧序列第一个节点之前</span><br>                parentElm.<span class="hljs-title function_">insertBefore</span>(oldVnode.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)<br>                <span class="hljs-title function_">patchVnode</span>(oldVnode, newStartVnode)<br>                <span class="hljs-comment">// 把这项设置成空，循环时遇到时跳过</span><br>                oldCh[idxInOld] = <span class="hljs-literal">undefined</span><br>            &#125;<br>            <span class="hljs-comment">// 当前新节点处理完毕，下一轮循环处理下一个新节点</span><br>            newStartVnode = newCh[++newStartIdx]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 循环结束了，start还是比end小，说明有节点没有处理到</span><br>    <span class="hljs-keyword">if</span> (newStartIdx &lt;= newEndIdx) &#123;<br>        <span class="hljs-comment">// 新节点没有处理到，则创建按DOM添加到新序列最后一个节点的前面</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;<br>            <span class="hljs-comment">// insertBefore方法传入null则添加到队尾</span><br>            <span class="hljs-keyword">const</span> before = newCh[newEndIdx + <span class="hljs-number">1</span>]?.<span class="hljs-property">elm</span> || <span class="hljs-literal">null</span><br>            parentElm.<span class="hljs-title function_">insertBefore</span>(<span class="hljs-title function_">createElement</span>(newCh[i]), before)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldStartIdx &lt;= oldEndIdx) &#123;<br>        <span class="hljs-comment">// 旧节点没有处理到，删除</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;<br>            parentElm.<span class="hljs-title function_">removeChild</span>(oldCh[i].<span class="hljs-property">elm</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码注释中及下文的新&#x2F;旧<strong>序列</strong>，仅包含从新&#x2F;旧<strong>开始索引到结束索引间的节点</strong>，也就是还未处理的节点序列，而不是整个子节点数组。</p></blockquote><h2 id="根据例子讲解"><a href="#根据例子讲解" class="headerlink" title="根据例子讲解"></a>根据例子讲解</h2><p>我们以下图的例子，来讲解这个函数的运行流程（方框中的内容为子节点的 key，所有节点标签相同）</p><p>首先定义了 8 个变量，表示新旧序列的开始和结束位置的索引与节点</p><p><img src="/10c92251651c4cc28f556696661d597btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>然后开始循环，初始时节点都不为空</p><p><strong>第一次循环命中情况 1，旧前与新前(key)相等</strong></p><p>这表示旧序列的第一个节点到新序列仍是第一个节点，也就不需要移动，但还需要比较一下节点的内容有没有改变(patchVnode)，并且让新旧开始索引都前进一步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 比较节点的数据及子节点，并且将旧节点的DOM赋给新节点</span><br><span class="hljs-title function_">patchVnode</span>(newStartVnode, oldStartVnode)<br>oldStartVnode = oldCh[++oldStartIdx]<br>newStartVnode = newCh[++newStartIdx]<br></code></pre></td></tr></table></figure><p><img src="/48585f8d2ded4db7bc73b5b566b811c1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>情况 1 是业务中最常见的，表示从前至后两两比较。一般把商品添加到购物车末尾，或是没有设置 key 值的子节点，都是依靠情况 1 把可复用的节点筛选完毕。</p><p><strong>第二次循环命中情况 2，旧后和新后相等</strong></p><p>这表示序列的末尾节点到新序列仍是末尾节点，也不需要移动，然后让新旧结束索引都后退一步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">patchVnode</span>(newEndVnode, oldEndVnode)<br>oldEndVnode = oldCh[--oldEndIdx]<br>newEndVnode = newCh[--newEndIdx]<br></code></pre></td></tr></table></figure><p><img src="/417842734e2b4209870a8717f4452079tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>情况 2 是情况 1 的补充，表示从后向前两两比较。有时会把新发布的评论插到开头，或者从购物车删除了一些商品，这时仅依靠情况 1 就无法迅速的筛选可复用节点，所以需要从后向前比较来配合。</p><p><strong>第三次循环命中情况 3，旧前和新后相等</strong></p><p>这表示旧序列的第一个节点，变成了新序列的最后一个节点。需要将这个节点移动到序列的末尾，也就是旧序列末尾节点的下一个节点(节点 e)的前面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parentElm.<span class="hljs-title function_">insertBefore</span>(oldStartVnode.<span class="hljs-property">elm</span>, oldEndVnode.<span class="hljs-property">elm</span>.<span class="hljs-property">nextSibling</span>)<br></code></pre></td></tr></table></figure><p><img src="/8482cb53c49c4be7bf0ea64c306c8852tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>然后比较新旧节点，修改索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">patchVnode</span>(newEndVnode, oldStartVnode)<br>oldStartVnode = oldCh[++oldStartIdx]<br>newEndVnode = newCh[--newEndIdx]<br></code></pre></td></tr></table></figure><p><img src="/c11982331fb1458ba3725e4547d88fe4tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>情况 3 主要处理数组反转的情况，比如升序改降序，每个起始节点被移动到了末尾的位置，使用此情况将它们重新排序。</p><p><strong>第四次循环命中情况 4，旧后与新前相等</strong></p><p>这表示旧序列的最后一个节点，变成了新序列的第一个节点。需要将这个节点移动到序列的开头，也就是旧序列开始节点（节点 c）的前面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parentElm.<span class="hljs-title function_">insertBefore</span>(oldStartVnode.<span class="hljs-property">elm</span>, oldEndVnode.<span class="hljs-property">elm</span>.<span class="hljs-property">nextSibling</span>)<br></code></pre></td></tr></table></figure><p><img src="/4bcde48abb8c44b8931081e0eecd21b6tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>到这里说一下，图上标注的是节点 a 的后面，是因为节点 b 被移动到了末尾</p><p><strong>节点的移动都是根据旧节点来定位的，如果想把一个节点放到序列的开头，就放到旧序列开始节点的前面；如果想把一个节点放到序列的末尾，就要放到旧序列结束节点的下一个节点的前面</strong></p><p>然后也是比较新旧节点，修改索引，之后是下图情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">patchVnode</span>(newStartVnode, oldEndVnode)<br>oldEndVnode = oldCh[--oldEndIdx]<br>newStartVnode = newCh[++newStartIdx]<br></code></pre></td></tr></table></figure><p><img src="/c0298603a19645be9b2ac4ea6352b8aftplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>情况 4 是情况 3 的补充，避免反转数组后又插入&#x2F;删除了节点导致情况 3 无法匹配，本例就是这个情况。</p><p><strong>第五次循环，4 种情况均为未命中</strong></p><p>很遗憾，无法迅速锁定节点的位置，只能用传统的方式进行遍历</p><p>我们这里选择了以空间换时间的方式，定义了 keyMap，将旧序列节点的 key 与索引存起来，然后使用新开始节点的 key 去查找。</p><p>如果没找到，说明这是一个新节点，创建节点并放到开头，也就是插入到旧序列开始节点的前面</p><p>但如果找到了，则同样移动节点到序列开头，然后将对应的旧节点索引置空，在以后循环遇到空的旧节点就跳过了</p><p>本例中是未找到的情况，此节点处理完毕，新开始索引加一，超过了新结束索引，不满足循环条件，退出循环</p><p><img src="/e0e823d81bb94d63adff7cd69006e3f4tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>然而，节点 c 并没有被处理，此时的 DOM 序列为：a,d,f,c,b,e</p><p>所以在循环之后，要检测是否有未处理的节点，如果是旧节点未处理，删除即可；</p><p>如果是新节点未处理，则创建新节点插入到<strong>旧序列的末尾</strong>或者<strong>旧序列的开头</strong>，二者其实是一个位置</p><p>我们假设旧节点中没有 c，则在第四次循环后就会出现以下情况（第四次循环命中的是情况 1）</p><p><img src="/a31a7f766b8c48b78e4227d2ddb476f1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>如果把 f 放到序列的开头，就是旧开始节点（节点 e）的前面</p><p>而如果把 f 放到序列的末尾，也就是旧结束节点的下一个节点（节点 e）的前面</p><p>此时旧序列就是一个点，不分开头和结尾，只要保证新增节点序列按序添加就好了</p><p>至此，双端 diff 算法就讲完了</p><h1 id="Vue-中的-key"><a href="#Vue-中的-key" class="headerlink" title="Vue 中的 key"></a>Vue 中的 key</h1><p>学完 diff 算法，再聊聊 key 的作用</p><h2 id="v-for-中的-key"><a href="#v-for-中的-key" class="headerlink" title="v-for 中的 key"></a>v-for 中的 key</h2><p>上面讲的都是有 key 情况下，diff 算法能够迅速找到新旧序列中的同一节点，以较小的代价完成更新。</p><p>而如果在 v-for 中不设置 key 呢？</p><p>假设我们在数组头部插入了一个新节点，然后开始循环，每次循环都命中情况 1，尝试“复用”此节点。</p><p>但是，在对比新旧节点的内容时，都会发现内容不同，需要用新节点的内容替换旧节点。这只是复用了 DOM 的外壳，节点的内容、数据以及该节点的子节点全都要更改。</p><p>相比有 key 时的只添加一个新节点，无 key 则将所有节点都修改一遍。</p><h2 id="v-if-自带-key"><a href="#v-if-自带-key" class="headerlink" title="v-if 自带 key"></a>v-if 自带 key</h2><p>v-for 以外的元素我们一般是不设置 key 的，但是如果子元素中有 v-if 的话，就像下面这个场景（abcd是内容，并不是 key），更新子元素又会复现上一节的情况。</p><p><img src="/b182b8cc704f4e36b3c980d77a21e0betplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="image.png"></p><p>然而 Vue 官方也考虑到了这点，会为 v-if 的元素加上利用 hash 函数生成的唯一 key</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以下出自 v2 源码</span><br><span class="hljs-keyword">var</span> needsKey = !!el.<span class="hljs-property">if</span> <br>……<br>needsKey ? <span class="hljs-string">&#x27;,null,false,&#x27;</span> + <span class="hljs-title function_">hash</span>(generatedSlots) : <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="key-的另一个用法"><a href="#key-的另一个用法" class="headerlink" title="key 的另一个用法"></a>key 的另一个用法</h2><p>顺便再提一嘴，key 可以绑到任意元素上，当 key 发生变化时，会导致 DOM 的销毁与重建，一般用来重复触发动画或生命周期钩子。</p><p>详情可看<a href="https://cn.vuejs.org/v2/api/#key">官方链接</a></p><br /><br /><p>参考：</p><p>[1]. <a href="https://juejin.cn/post/7120919895713251335">聊聊 Vue2 是如何更新节点的 | diff 算法详解 - 掘金 (juejin.cn)</a></p><p>[2]. <a href="https://segmentfault.com/a/1190000043632772#item-8">javascript - Vue2 diff 算法图解 - Vuejs源码解析 - SegmentFault 思否</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diff</tag>
      
      <tag>双端算法</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript原型与原型链学习</title>
    <link href="/2023/07/10/JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/10/JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>​JavaScript作为一个基于原型的OOP，和我们熟知的基于类的面向对象编程语言有很大的差异。如果不理解其中的本质含义，则无法深入理解JavaScript的诸多特性。</p><p>​在基于类的编程语言中，都要先抽象出一个“类”，用来统一表示同一种对象。然后用这个抽象类创建出一个个实例（泛化），也就是对象object。最后，类和类之间通过组合、继承等特性共建出一个可以互动的系统，从而用这套人为创建的系统来模拟、操纵现实中的物理世界。它的三大特性为：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p>然而，在原型概念中，有很多不同之处。基于原型的编程范式提倡程序设计者关注实例对象的一系列行为，然后根据行为的不同划分出不同的原型，而不是事先抽象出一个类，再关注具体的对象。它最大的特点是可以动态修改对象的行为，具有高度灵活性。</p><p>如果把基于类的对象称为“自上而下”式的顶层设计，那么基于原型的对象则可以被称为“自下而上”式的动态演化。</p><blockquote><p>基于原型的面向对象系统通过“复制”的方式来创建新对象，这实际上就是创建一个全新的对象。</p></blockquote><p>原型系统的“复制”操作有两种实现思路：</p><ul><li>并不是真正的复制一个对象，而是使新对象持有一个原型的引用；</li><li>切实的复制一个对象，复制对象和被复制对象再无任何关联。</li></ul><p><strong>原型链</strong></p><p>JavaScript的每个对象都有一个指向其原型对象的关系链，当试图访问一个属性时，它不仅仅在对象上搜寻，而且还会在它的原型上搜寻，以及原型的原型上搜寻，直到找到属性或者达到此链条的顶端，这就是JavaScript的原型链，用来实现继承的核心逻辑。</p><p>原型链经典图</p><p><img src="/2023/07/10/JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AD%A6%E4%B9%A0/%E5%8E%9F%E5%9E%8B%E9%93%BE1.jpg" alt="原型链1"></p><p><img src="/2023/07/10/JavaScript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AD%A6%E4%B9%A0/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%8F%E5%85%B8%E5%9B%BE.jpg" alt="原型链经典图"></p><p><strong>总结</strong></p><ul><li>牢记三点：<br> - __proto__属性是对象所独有的；</li></ul><p> - prototype属性是函数所独有的；</p><p> - 因为函数也是一种对象，所以同时拥有__proto__属性和prototype属性。</p><ul><li><p>__proto__属性的作用是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__所指向的那个对象里找，一直找，直到__proto__属性为null，再往上会报错，因为null没有原型。通过__proto__属性将对象的继承关系连接起来的这条链路即原型链。</p></li><li><p>prototype属性的作用是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Foo.prototype。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用Typora和GithubPages部署博客图片路径问题</title>
    <link href="/2023/02/17/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/17/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li><p>首先引用 hexo-renderer-marked 包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo-renderer-marked --save<br></code></pre></td></tr></table></figure></li><li><p>修改博客项目根目录下_config.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>    <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>开启了之后，图片资源就会自动解析成对应的图片路径。比如：“test.jpg” 位于 “&#x2F;2022&#x2F;04&#x2F;25&#x2F;test&#x2F;test.jpg”</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">!<span class="hljs-selector-attr">[]</span>(test.jpg)` 将会转换成 `&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;/2022/04/25/test/test.jpg&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li></ol><p>这种方式，虽然能解决发布之后图片展示的问题，但是不能解决本地typora编辑的问题，例如：有如下的目录结构：</p><blockquote><p><img src="/2023/02/17/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/webp.webp" alt="img"></p></blockquote><p>编辑hexo-github.md文件，如果写成：</p><blockquote><p><img src="/2023/02/17/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/webp-16766246268032.webp" alt="img"></p></blockquote><p>这种相对路径之后，能在typora中显示图片，但是在网页上就不能展示图片，如果改成下面这种：</p><blockquote><p><img src="/2023/02/17/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/webp-16766246469994.webp" alt="img"></p></blockquote><p>能在网页上显示图片，但是在typora中又不能显示，这个时候，我们就通过修改插件 hexo-renderer-marked 的代码，来兼容两方的需求，找到图片路径转换的代码：</p><blockquote><p><img src="/2023/02/17/hexo-typora-github%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/webp-16766246706976.webp" alt="img"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&gt;<span class="hljs-keyword">if</span> (href.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &gt; -<span class="hljs-number">1</span>) &#123;<br>   href = href.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">1</span>];<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><p>其中红框中的代码就是新加的，这样我们在md文件中，路径写成：<br>hexo-github&#x2F;image-20220423232811690.png 这样，就能同时在typora和网页上进行展示</p><p>最后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo clean<br>hexo g<br>hexo s<br>hexo d<br></code></pre></td></tr></table></figure><p>typora相关设置参考链接：<a href="https://www.bilibili.com/read/cv12633102/">2021最全hexo搭建博客+matery美化+使用（保姆级教程） - 哔哩哔哩</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>typora</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00Devtools前置知识</title>
    <link href="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Renderer-Process"><a href="#Renderer-Process" class="headerlink" title="Renderer Process"></a>Renderer Process</h1><blockquote><p>渲染器进程：Chrome 的多进程架构中，每打开一个 tab页 都会独立运行一个渲染器进程，从而保证某一 tab页 无响应或崩溃不会影响其他 tab页 的活动。</p></blockquote><h3 id="Chrome-中的进程与分工"><a href="#Chrome-中的进程与分工" class="headerlink" title="Chrome 中的进程与分工"></a><strong>Chrome 中的进程与分工</strong></h3><blockquote><p>![Chrome 中的进程与分工-](00Devtools前置知识&#x2F;Chrome 中的进程与分工-.png)</p></blockquote><ul><li><strong>浏览器进程（Browser Process）</strong>：控制 chrome 应用程序，包括地址栏、书签、后退和前进按钮。还处理 Web 浏览器的不可见的特权部分，例如网络请求和文件访问。</li><li><strong>渲染器进程（Renderer Process）</strong>：控制tab页中所有内容的显示。</li><li><strong>插件进程（Plugin Process）</strong>：控制网站使用的任何插件，例如 flash。</li><li><strong>图形处理器进程（GPU Process</strong>）：独立于其他进程处理 GPU 任务。</li></ul><h3 id="渲染器进程中的线程"><a href="#渲染器进程中的线程" class="headerlink" title="渲染器进程中的线程"></a><strong>渲染器进程中的线程</strong></h3><blockquote><p><strong>渲染器进程包含主线程（main thread）、工作线程（worker threads）、合成线程（compositor thread）和光栅线程（raster thread）。</strong></p><br><p><img src="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E6%B8%B2%E6%9F%93%E5%99%A8%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B.png" alt="渲染器进程中的线程"></p></blockquote><h2 id="页面渲染步骤"><a href="#页面渲染步骤" class="headerlink" title="页面渲染步骤"></a>页面渲染步骤</h2><p>渲染器进程的核心工作是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，主要步骤如下：</p><h3 id="1-DOM-解析"><a href="#1-DOM-解析" class="headerlink" title="1.DOM 解析 "></a>1.DOM 解析 <em><Parsing></em></h3><p>渲染进程解析接收到的HTML数据并转化为DOM对象。</p><h3 id="2-样式计算"><a href="#2-样式计算" class="headerlink" title="2.样式计算 "></a>2.样式计算 <em><Stylecal Culation></em></h3><p>主线程根据 CSS 样式选择器计算出的每个DOM元素应具备的具体样式。</p><h3 id="3-布局"><a href="#3-布局" class="headerlink" title="3.布局 "></a>3.布局 <em><Layout></em></h3><p>经过上面的步骤虽然已经知道页面的具体文档结构以及每个节点拥有的样式信息，但仍然不能确定页面最终的样子。布局的过程是计算出每个节点的几何信息。</p><blockquote><p><strong>布局过程中主线程会遍历构建的DOM树，根据DOM节点的计算样式计算出一个布局树（layout tree）</strong></p><br><p><img src="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/LayoutTree.png" alt="LayoutTree"></p><br><p>布局树上每个节点会有它在页面上的x，y坐标以及盒子大小（bounding box sizes）的具体信息。布局树与先前构建的DOM树差不多，不同的是只有那些可见的节点。</p></blockquote><h3 id="4-分层"><a href="#4-分层" class="headerlink" title="4.分层 "></a>4.分层 <em><Dividing into layers></em></h3><p>分层的作用确定哪些元素需要放置在哪一图层，此过程主线程会遍历布局树来创建一棵层次树（Layer Tree）。在DevTools中这一部分工作叫做 <code>Update Layer Tree</code>。分层与合成（Compositing）息息相关，在后面详细介绍。</p><blockquote><p><img src="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%88%86%E5%B1%82.jpg" alt="分层"></p></blockquote><h3 id="5-绘制"><a href="#5-绘制" class="headerlink" title="5.绘制 "></a>5.绘制 <em><Paint></em></h3><p>有了 DOM、样式和布局信息仍不足以呈现页面。比如某些元素设置了<code>z-index</code>，仅按照 HTML 元素的顺序会导致渲染的结果不正确，所以还需要知道绘制的顺序。主线程会遍历之前的布局树（layout tree）来生成一系列的绘画记录（paint records），从而得到了绘制的顺序。</p><blockquote><p><img src="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E7%BB%98%E5%88%B6.jpg" alt="绘制"></p></blockquote><h3 id="6-合成"><a href="#6-合成" class="headerlink" title="6.合成 "></a>6.合成 <em><Compositing></em></h3><p>经过上面的步骤，浏览器知道了文档结构、每个元素的样式、页面的几何形状和绘制顺序。浏览器就可以开始绘制页面。而将这些信息转化为显示器的像素的过程叫做 <strong>光栅化</strong>。 光栅化最简单的做法就是只光栅化视口内的内容。如果用户进行了页面滚动，就移动光栅帧（rastered frame）光栅化更多的内容以填充缺失的部分，最初的 Chrome 就是这么做的。对于现代的浏览器来说采取一种更加复杂的做法，叫做合成（compositing）。合成是一种将页面分成若干层，分别对它们进行光栅化，然后在一个单独的线程 — 合成线程（compositor thread）里合成为一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果。动画则可以通过移动图层并合成新帧以相同的方式实现。</p><h2 id="光栅化与合成"><a href="#光栅化与合成" class="headerlink" title="光栅化与合成"></a>光栅化与合成</h2><p>合成的过程类似 Photoshop 将多个图层按顺序叠加后导出最终的图片，图像发生变更也只需要调整对应的图层。合成的详细过程：</p><h3 id="1-分层"><a href="#1-分层" class="headerlink" title="1.  分层 "></a>1.  <strong>分层</strong> <em><Dividing into layers></em></h3><p>合成之前需要主线程先将页面分成若干层。为了确定哪些元素需要放置在哪一层，主线程需要遍历布局树来创建一棵层次树（Layer Tree），在DevTools中这一部分工作叫做 <code>Update Layer Tree</code>。</p><blockquote><p><img src="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%89%E6%A0%85%E5%8C%96-%E5%88%86%E5%B1%82.jpg" alt="光栅化-分层"></p></blockquote><p>也可以使用 <code>will-change</code> CSS 属性告诉浏览器对其单独分层。你甚至可以给页面上所有的元素一个单独的层，但分层并不是越多越好，当页面的层数超过一定数量后，分层的合成操作会比在每帧中光栅化页面的一小部分还要慢。在 Frames 或 DevTools <code>Layers</code> 面板中可查看网站如何被分层</p><blockquote><p><img src="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%89%E6%A0%85%E5%8C%96-%E5%88%86%E5%B1%822.jpg" alt="光栅化-分层2"></p><p><img src="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%89%E6%A0%85%E5%8C%96-%E5%88%86%E5%B1%821.jpg" alt="光栅化-分层1"></p></blockquote><h3 id="2-光栅化分层"><a href="#2-光栅化分层" class="headerlink" title="2. 光栅化分层"></a>2. 光栅化分层</h3><p>光栅线程光栅化分层。一旦创建了<code>Layer Tree</code>并确定了绘制顺序，主线程就会向合成线程（compositor thread）提交这些信息。然后合成线程就会光栅化页面的每一层，因为页面的一层可能有整个网页那么大，所以合成器进程需要将它们切分为若干的切片然后将每个切片发送给光栅线程（raster thread），光栅线程会光栅化每个切片并且把它们存储在GPU的内存中。</p><blockquote><p><img src="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%89%E6%A0%85%E5%8C%96-%E5%88%86%E5%B1%823.jpg" alt="光栅化-分层3"></p></blockquote><p>合成器进程可以对不同的光栅线程进行优先级排序，以便优先对视口内（或附近）的内容进行光栅化。</p><h3 id="3-合成"><a href="#3-合成" class="headerlink" title="3.  合成"></a>3.  合成</h3><p>对切片进行光栅化后，合成器线程会收集切片信息（draw quads）来构建一个合成帧（compositor frame）。</p><ul><li><code>draw quads</code>：包含切片在内存的位置以及图层合成后切片在页面的位置信息。</li><li><code>compositor frame</code>： 绘制一帧内容的 draw quads 集合。</li></ul><p>然后通过IPC将合成帧提交给浏览器进程（browser process）。此时 UI 线程或其他渲染器进程也可以添加另外的合成帧，这些合成帧被发送到 GPU 以显示在屏幕上。如果如果出现滚动事件，合成器线程会创建另一个合成帧发送到 GPU 用来更新页面。</p><blockquote><p><img src="/2023/02/16/00Devtools%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/%E5%85%89%E6%A0%85%E5%8C%96-%E5%90%88%E6%88%90.jpg" alt="光栅化-合成"></p></blockquote><p>合成的好处在于它无需涉及主线程即可完成。合成器进程不需要等待样式计算（Style calculation）或 JavaScript 执行。这就是为什么<a href="https://link.juejin.cn/?target=https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">仅通过合成实现动画</a>是最推荐的方式，能取得最好的性能体验。如果需要重新计算布局（layout）或绘制（paint）则必须涉及到主线程。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>Devtools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Chrome</tag>
      
      <tag>Devtools</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
